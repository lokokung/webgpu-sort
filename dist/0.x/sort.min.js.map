{"version":3,"file":"sort.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../src/external/greggman/webgpu-utils/webgpu-utils.module.js","../../src/common/util/util.ts","../../src/webgpu/util/math.ts","../../src/webgpu/util/buffer.ts","../../src/sort.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","/* webgpu-utils@0.2.4, license MIT */\n/**\n * @class Node\n * @category AST\n * Base class for AST nodes parsed from a WGSL shader.\n */\nclass Node {\n    constructor() { }\n    get isAstNode() {\n        return true;\n    }\n    get astNodeType() {\n        return \"\";\n    }\n}\n/**\n * @class Statement\n * @extends Node\n * @category AST\n */\nclass Statement extends Node {\n    constructor() {\n        super();\n    }\n}\n/**\n * @class Function\n * @extends Statement\n * @category AST\n */\nclass Function extends Statement {\n    constructor(name, args, returnType, body) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.returnType = returnType;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"function\";\n    }\n}\n/**\n * @class StaticAssert\n * @extends Statement\n * @category AST\n */\nclass StaticAssert extends Statement {\n    constructor(expression) {\n        super();\n        this.expression = expression;\n    }\n    get astNodeType() {\n        return \"staticAssert\";\n    }\n}\n/**\n * @class While\n * @extends Statement\n * @category AST\n */\nclass While extends Statement {\n    constructor(condition, body) {\n        super();\n        this.condition = condition;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"while\";\n    }\n}\n/**\n * @class For\n * @extends Statement\n * @category AST\n */\nclass For extends Statement {\n    constructor(init, condition, increment, body) {\n        super();\n        this.init = init;\n        this.condition = condition;\n        this.increment = increment;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"for\";\n    }\n}\n/**\n * @class Var\n * @extends Statement\n * @category AST\n */\nclass Var extends Statement {\n    constructor(name, type, storage, access, value) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.storage = storage;\n        this.access = access;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"var\";\n    }\n}\n/**\n * @class Let\n * @extends Statement\n * @category AST\n */\nclass Let extends Statement {\n    constructor(name, type, storage, access, value) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.storage = storage;\n        this.access = access;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"let\";\n    }\n}\n/**\n * @class Const\n * @extends Statement\n * @category AST\n */\nclass Const extends Statement {\n    constructor(name, type, storage, access, value) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.storage = storage;\n        this.access = access;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"const\";\n    }\n}\nvar IncrementOperator;\n(function (IncrementOperator) {\n    IncrementOperator[\"increment\"] = \"++\";\n    IncrementOperator[\"decrement\"] = \"--\";\n})(IncrementOperator || (IncrementOperator = {}));\n(function (IncrementOperator) {\n    function parse(val) {\n        const key = val;\n        if (key == \"parse\")\n            throw new Error(\"Invalid value for IncrementOperator\");\n        return IncrementOperator[key];\n    }\n    IncrementOperator.parse = parse;\n})(IncrementOperator || (IncrementOperator = {}));\n/**\n * @class Increment\n * @extends Statement\n * @category AST\n */\nclass Increment extends Statement {\n    constructor(operator, variable) {\n        super();\n        this.operator = operator;\n        this.variable = variable;\n    }\n    get astNodeType() {\n        return \"increment\";\n    }\n}\nvar AssignOperator;\n(function (AssignOperator) {\n    AssignOperator[\"assign\"] = \"=\";\n    AssignOperator[\"addAssign\"] = \"+=\";\n    AssignOperator[\"subtractAssin\"] = \"-=\";\n    AssignOperator[\"multiplyAssign\"] = \"*=\";\n    AssignOperator[\"divideAssign\"] = \"/=\";\n    AssignOperator[\"moduloAssign\"] = \"%=\";\n    AssignOperator[\"andAssign\"] = \"&=\";\n    AssignOperator[\"orAssign\"] = \"|=\";\n    AssignOperator[\"xorAssign\"] = \"^=\";\n    AssignOperator[\"shiftLeftAssign\"] = \"<<=\";\n    AssignOperator[\"shiftRightAssign\"] = \">>=\";\n})(AssignOperator || (AssignOperator = {}));\n(function (AssignOperator) {\n    function parse(val) {\n        const key = val;\n        if (key == \"parse\")\n            throw new Error(\"Invalid value for AssignOperator\");\n        return AssignOperator[key];\n    }\n    AssignOperator.parse = parse;\n})(AssignOperator || (AssignOperator = {}));\n/**\n * @class Assign\n * @extends Statement\n * @category AST\n */\nclass Assign extends Statement {\n    constructor(operator, variable, value) {\n        super();\n        this.operator = operator;\n        this.variable = variable;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"assign\";\n    }\n}\n/**\n * @class Call\n * @extends Statement\n * @category AST\n */\nclass Call extends Statement {\n    constructor(name, args) {\n        super();\n        this.name = name;\n        this.args = args;\n    }\n    get astNodeType() {\n        return \"call\";\n    }\n}\n/**\n * @class Loop\n * @extends Statement\n * @category AST\n */\nclass Loop extends Statement {\n    constructor(body, continuing) {\n        super();\n        this.body = body;\n        this.continuing = continuing;\n    }\n    get astNodeType() {\n        return \"loop\";\n    }\n}\n/**\n * @class Switch\n * @extends Statement\n * @category AST\n */\nclass Switch extends Statement {\n    constructor(condition, body) {\n        super();\n        this.condition = condition;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"body\";\n    }\n}\n/**\n * @class If\n * @extends Statement\n * @category AST\n */\nclass If extends Statement {\n    constructor(condition, body, elseif, _else) {\n        super();\n        this.condition = condition;\n        this.body = body;\n        this.elseif = elseif;\n        this.else = _else;\n    }\n    get astNodeType() {\n        return \"if\";\n    }\n}\n/**\n * @class Return\n * @extends Statement\n * @category AST\n */\nclass Return extends Statement {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"return\";\n    }\n}\n/**\n * @class Struct\n * @extends Statement\n * @category AST\n */\nclass Struct extends Statement {\n    constructor(name, members) {\n        super();\n        this.name = name;\n        this.members = members;\n    }\n    get astNodeType() {\n        return \"struct\";\n    }\n}\n/**\n * @class Enable\n * @extends Statement\n * @category AST\n */\nclass Enable extends Statement {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    get astNodeType() {\n        return \"enable\";\n    }\n}\n/**\n * @class Alias\n * @extends Statement\n * @category AST\n */\nclass Alias extends Statement {\n    constructor(name, type) {\n        super();\n        this.name = name;\n        this.type = type;\n    }\n    get astNodeType() {\n        return \"alias\";\n    }\n}\n/**\n * @class Discard\n * @extends Statement\n * @category AST\n */\nclass Discard extends Statement {\n    constructor() {\n        super();\n    }\n    get astNodeType() {\n        return \"discard\";\n    }\n}\n/**\n * @class Break\n * @extends Statement\n * @category AST\n */\nclass Break extends Statement {\n    constructor() {\n        super();\n    }\n    get astNodeType() {\n        return \"break\";\n    }\n}\n/**\n * @class Continue\n * @extends Statement\n * @category AST\n */\nclass Continue extends Statement {\n    constructor() {\n        super();\n    }\n    get astNodeType() {\n        return \"continue\";\n    }\n}\n/**\n * @class Type\n * @extends Node\n * @category AST\n */\nclass Type extends Node {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    get astNodeType() {\n        return \"type\";\n    }\n}\n/**\n * @class TemplateType\n * @extends Type\n * @category AST\n */\nclass TemplateType extends Type {\n    constructor(name, format, access) {\n        super(name);\n        this.format = format;\n        this.access = access;\n    }\n    get astNodeType() {\n        return \"template\";\n    }\n}\n/**\n * @class PointerType\n * @extends Type\n * @category AST\n */\nclass PointerType extends Type {\n    constructor(name, storage, type, access) {\n        super(name);\n        this.storage = storage;\n        this.type = type;\n        this.access = access;\n    }\n    get astNodeType() {\n        return \"pointer\";\n    }\n}\n/**\n * @class ArrayType\n * @extends Type\n * @category AST\n */\nclass ArrayType extends Type {\n    constructor(name, attributes, format, count) {\n        super(name);\n        this.attributes = attributes;\n        this.format = format;\n        this.count = count;\n    }\n    get astNodeType() {\n        return \"array\";\n    }\n}\n/**\n * @class SamplerType\n * @extends Type\n * @category AST\n */\nclass SamplerType extends Type {\n    constructor(name, format, access) {\n        super(name);\n        this.format = format;\n        this.access = access;\n    }\n    get astNodeType() {\n        return \"sampler\";\n    }\n}\n/**\n * @class Expression\n * @extends Node\n * @category AST\n */\nclass Expression extends Node {\n    constructor() {\n        super();\n    }\n}\n/**\n * @class StringExpr\n * @extends Expression\n * @category AST\n */\nclass StringExpr extends Expression {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"stringExpr\";\n    }\n    toString() {\n        return this.value;\n    }\n}\n/**\n * @class CreateExpr\n * @extends Expression\n * @category AST\n */\nclass CreateExpr extends Expression {\n    constructor(type, args) {\n        super();\n        this.type = type;\n        this.args = args;\n    }\n    get astNodeType() {\n        return \"createExpr\";\n    }\n}\n/**\n * @class CallExpr\n * @extends Expression\n * @category AST\n */\nclass CallExpr extends Expression {\n    constructor(name, args) {\n        super();\n        this.name = name;\n        this.args = args;\n    }\n    get astNodeType() {\n        return \"callExpr\";\n    }\n}\n/**\n * @class VariableExpr\n * @extends Expression\n * @category AST\n */\nclass VariableExpr extends Expression {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    get astNodeType() {\n        return \"varExpr\";\n    }\n}\n/**\n * @class LiteralExpr\n * @extends Expression\n * @category AST\n */\nclass LiteralExpr extends Expression {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"literalExpr\";\n    }\n}\n/**\n * @class BitcastExpr\n * @extends Expression\n * @category AST\n */\nclass BitcastExpr extends Expression {\n    constructor(type, value) {\n        super();\n        this.type = type;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"bitcastExpr\";\n    }\n}\n/**\n * @class TypecastExpr\n * @extends Expression\n * @category AST\n */\nclass TypecastExpr extends Expression {\n    constructor(type, args) {\n        super();\n        this.type = type;\n        this.args = args;\n    }\n    get astNodeType() {\n        return \"typecastExpr\";\n    }\n}\n/**\n * @class GroupingExpr\n * @extends Expression\n * @category AST\n */\nclass GroupingExpr extends Expression {\n    constructor(contents) {\n        super();\n        this.contents = contents;\n    }\n    get astNodeType() {\n        return \"groupExpr\";\n    }\n}\n/**\n * @class Operator\n * @extends Expression\n * @category AST\n */\nclass Operator extends Expression {\n    constructor() {\n        super();\n    }\n}\n/**\n * @class UnaryOperator\n * @extends Operator\n * @category AST\n */\nclass UnaryOperator extends Operator {\n    constructor(operator, right) {\n        super();\n        this.operator = operator;\n        this.right = right;\n    }\n    get astNodeType() {\n        return \"unaryOp\";\n    }\n}\n/**\n * @class BinaryOperator\n * @extends Operator\n * @category AST\n */\nclass BinaryOperator extends Operator {\n    constructor(operator, left, right) {\n        super();\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n    get astNodeType() {\n        return \"binaryOp\";\n    }\n}\n/**\n * @class SwitchCase\n * @extends Node\n * @category AST\n */\nclass SwitchCase extends Node {\n    constructor() {\n        super();\n    }\n}\n/**\n * @class Case\n * @extends SwitchCase\n * @category AST\n */\nclass Case extends SwitchCase {\n    constructor(selector, body) {\n        super();\n        this.selector = selector;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"case\";\n    }\n}\n/**\n * @class Default\n * @extends SwitchCase\n * @category AST\n */\nclass Default extends SwitchCase {\n    constructor(body) {\n        super();\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"default\";\n    }\n}\n/**\n * @class Argument\n * @extends Node\n * @category AST\n */\nclass Argument extends Node {\n    constructor(name, type, attributes) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.attributes = attributes;\n    }\n    get astNodeType() {\n        return \"argument\";\n    }\n}\n/**\n * @class ElseIf\n * @extends Node\n * @category AST\n */\nclass ElseIf extends Node {\n    constructor(condition, body) {\n        super();\n        this.condition = condition;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"elseif\";\n    }\n}\n/**\n * @class Member\n * @extends Node\n * @category AST\n */\nclass Member extends Node {\n    constructor(name, type, attributes) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.attributes = attributes;\n    }\n    get astNodeType() {\n        return \"member\";\n    }\n}\n/**\n * @class Attribute\n * @extends Node\n * @category AST\n */\nclass Attribute extends Node {\n    constructor(name, value) {\n        super();\n        this.name = name;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"attribute\";\n    }\n}\n\nvar _a;\nvar TokenClass;\n(function (TokenClass) {\n    TokenClass[TokenClass[\"token\"] = 0] = \"token\";\n    TokenClass[TokenClass[\"keyword\"] = 1] = \"keyword\";\n    TokenClass[TokenClass[\"reserved\"] = 2] = \"reserved\";\n})(TokenClass || (TokenClass = {}));\nclass TokenType {\n    constructor(name, type, rule) {\n        this.name = name;\n        this.type = type;\n        this.rule = rule;\n    }\n    toString() {\n        return this.name;\n    }\n}\n/// Catalog of defined token types, keywords, and reserved words.\nclass TokenTypes {\n}\n_a = TokenTypes;\nTokenTypes.none = new TokenType(\"\", TokenClass.reserved, \"\");\nTokenTypes.eof = new TokenType(\"EOF\", TokenClass.token, \"\");\nTokenTypes.reserved = {\n    asm: new TokenType(\"asm\", TokenClass.reserved, \"asm\"),\n    bf16: new TokenType(\"bf16\", TokenClass.reserved, \"bf16\"),\n    do: new TokenType(\"do\", TokenClass.reserved, \"do\"),\n    enum: new TokenType(\"enum\", TokenClass.reserved, \"enum\"),\n    f16: new TokenType(\"f16\", TokenClass.reserved, \"f16\"),\n    f64: new TokenType(\"f64\", TokenClass.reserved, \"f64\"),\n    handle: new TokenType(\"handle\", TokenClass.reserved, \"handle\"),\n    i8: new TokenType(\"i8\", TokenClass.reserved, \"i8\"),\n    i16: new TokenType(\"i16\", TokenClass.reserved, \"i16\"),\n    i64: new TokenType(\"i64\", TokenClass.reserved, \"i64\"),\n    mat: new TokenType(\"mat\", TokenClass.reserved, \"mat\"),\n    premerge: new TokenType(\"premerge\", TokenClass.reserved, \"premerge\"),\n    regardless: new TokenType(\"regardless\", TokenClass.reserved, \"regardless\"),\n    typedef: new TokenType(\"typedef\", TokenClass.reserved, \"typedef\"),\n    u8: new TokenType(\"u8\", TokenClass.reserved, \"u8\"),\n    u16: new TokenType(\"u16\", TokenClass.reserved, \"u16\"),\n    u64: new TokenType(\"u64\", TokenClass.reserved, \"u64\"),\n    unless: new TokenType(\"unless\", TokenClass.reserved, \"unless\"),\n    using: new TokenType(\"using\", TokenClass.reserved, \"using\"),\n    vec: new TokenType(\"vec\", TokenClass.reserved, \"vec\"),\n    void: new TokenType(\"void\", TokenClass.reserved, \"void\"),\n};\nTokenTypes.keywords = {\n    array: new TokenType(\"array\", TokenClass.keyword, \"array\"),\n    atomic: new TokenType(\"atomic\", TokenClass.keyword, \"atomic\"),\n    bool: new TokenType(\"bool\", TokenClass.keyword, \"bool\"),\n    f32: new TokenType(\"f32\", TokenClass.keyword, \"f32\"),\n    i32: new TokenType(\"i32\", TokenClass.keyword, \"i32\"),\n    mat2x2: new TokenType(\"mat2x2\", TokenClass.keyword, \"mat2x2\"),\n    mat2x3: new TokenType(\"mat2x3\", TokenClass.keyword, \"mat2x3\"),\n    mat2x4: new TokenType(\"mat2x4\", TokenClass.keyword, \"mat2x4\"),\n    mat3x2: new TokenType(\"mat3x2\", TokenClass.keyword, \"mat3x2\"),\n    mat3x3: new TokenType(\"mat3x3\", TokenClass.keyword, \"mat3x3\"),\n    mat3x4: new TokenType(\"mat3x4\", TokenClass.keyword, \"mat3x4\"),\n    mat4x2: new TokenType(\"mat4x2\", TokenClass.keyword, \"mat4x2\"),\n    mat4x3: new TokenType(\"mat4x3\", TokenClass.keyword, \"mat4x3\"),\n    mat4x4: new TokenType(\"mat4x4\", TokenClass.keyword, \"mat4x4\"),\n    ptr: new TokenType(\"ptr\", TokenClass.keyword, \"ptr\"),\n    sampler: new TokenType(\"sampler\", TokenClass.keyword, \"sampler\"),\n    sampler_comparison: new TokenType(\"sampler_comparison\", TokenClass.keyword, \"sampler_comparison\"),\n    struct: new TokenType(\"struct\", TokenClass.keyword, \"struct\"),\n    texture_1d: new TokenType(\"texture_1d\", TokenClass.keyword, \"texture_1d\"),\n    texture_2d: new TokenType(\"texture_2d\", TokenClass.keyword, \"texture_2d\"),\n    texture_2d_array: new TokenType(\"texture_2d_array\", TokenClass.keyword, \"texture_2d_array\"),\n    texture_3d: new TokenType(\"texture_3d\", TokenClass.keyword, \"texture_3d\"),\n    texture_cube: new TokenType(\"texture_cube\", TokenClass.keyword, \"texture_cube\"),\n    texture_cube_array: new TokenType(\"texture_cube_array\", TokenClass.keyword, \"texture_cube_array\"),\n    texture_multisampled_2d: new TokenType(\"texture_multisampled_2d\", TokenClass.keyword, \"texture_multisampled_2d\"),\n    texture_storage_1d: new TokenType(\"texture_storage_1d\", TokenClass.keyword, \"texture_storage_1d\"),\n    texture_storage_2d: new TokenType(\"texture_storage_2d\", TokenClass.keyword, \"texture_storage_2d\"),\n    texture_storage_2d_array: new TokenType(\"texture_storage_2d_array\", TokenClass.keyword, \"texture_storage_2d_array\"),\n    texture_storage_3d: new TokenType(\"texture_storage_3d\", TokenClass.keyword, \"texture_storage_3d\"),\n    texture_depth_2d: new TokenType(\"texture_depth_2d\", TokenClass.keyword, \"texture_depth_2d\"),\n    texture_depth_2d_array: new TokenType(\"texture_depth_2d_array\", TokenClass.keyword, \"texture_depth_2d_array\"),\n    texture_depth_cube: new TokenType(\"texture_depth_cube\", TokenClass.keyword, \"texture_depth_cube\"),\n    texture_depth_cube_array: new TokenType(\"texture_depth_cube_array\", TokenClass.keyword, \"texture_depth_cube_array\"),\n    texture_depth_multisampled_2d: new TokenType(\"texture_depth_multisampled_2d\", TokenClass.keyword, \"texture_depth_multisampled_2d\"),\n    u32: new TokenType(\"u32\", TokenClass.keyword, \"u32\"),\n    vec2: new TokenType(\"vec2\", TokenClass.keyword, \"vec2\"),\n    vec3: new TokenType(\"vec3\", TokenClass.keyword, \"vec3\"),\n    vec4: new TokenType(\"vec4\", TokenClass.keyword, \"vec4\"),\n    bitcast: new TokenType(\"bitcast\", TokenClass.keyword, \"bitcast\"),\n    block: new TokenType(\"block\", TokenClass.keyword, \"block\"),\n    break: new TokenType(\"break\", TokenClass.keyword, \"break\"),\n    case: new TokenType(\"case\", TokenClass.keyword, \"case\"),\n    continue: new TokenType(\"continue\", TokenClass.keyword, \"continue\"),\n    continuing: new TokenType(\"continuing\", TokenClass.keyword, \"continuing\"),\n    default: new TokenType(\"default\", TokenClass.keyword, \"default\"),\n    discard: new TokenType(\"discard\", TokenClass.keyword, \"discard\"),\n    else: new TokenType(\"else\", TokenClass.keyword, \"else\"),\n    elseif: new TokenType(\"elseif\", TokenClass.keyword, \"elseif\"),\n    enable: new TokenType(\"enable\", TokenClass.keyword, \"enable\"),\n    fallthrough: new TokenType(\"fallthrough\", TokenClass.keyword, \"fallthrough\"),\n    false: new TokenType(\"false\", TokenClass.keyword, \"false\"),\n    fn: new TokenType(\"fn\", TokenClass.keyword, \"fn\"),\n    for: new TokenType(\"for\", TokenClass.keyword, \"for\"),\n    function: new TokenType(\"function\", TokenClass.keyword, \"function\"),\n    if: new TokenType(\"if\", TokenClass.keyword, \"if\"),\n    let: new TokenType(\"let\", TokenClass.keyword, \"let\"),\n    const: new TokenType(\"const\", TokenClass.keyword, \"const\"),\n    loop: new TokenType(\"loop\", TokenClass.keyword, \"loop\"),\n    while: new TokenType(\"while\", TokenClass.keyword, \"while\"),\n    private: new TokenType(\"private\", TokenClass.keyword, \"private\"),\n    read: new TokenType(\"read\", TokenClass.keyword, \"read\"),\n    read_write: new TokenType(\"read_write\", TokenClass.keyword, \"read_write\"),\n    return: new TokenType(\"return\", TokenClass.keyword, \"return\"),\n    storage: new TokenType(\"storage\", TokenClass.keyword, \"storage\"),\n    switch: new TokenType(\"switch\", TokenClass.keyword, \"switch\"),\n    true: new TokenType(\"true\", TokenClass.keyword, \"true\"),\n    type: new TokenType(\"type\", TokenClass.keyword, \"type\"),\n    uniform: new TokenType(\"uniform\", TokenClass.keyword, \"uniform\"),\n    var: new TokenType(\"var\", TokenClass.keyword, \"var\"),\n    workgroup: new TokenType(\"workgroup\", TokenClass.keyword, \"workgroup\"),\n    write: new TokenType(\"write\", TokenClass.keyword, \"write\"),\n    r8unorm: new TokenType(\"r8unorm\", TokenClass.keyword, \"r8unorm\"),\n    r8snorm: new TokenType(\"r8snorm\", TokenClass.keyword, \"r8snorm\"),\n    r8uint: new TokenType(\"r8uint\", TokenClass.keyword, \"r8uint\"),\n    r8sint: new TokenType(\"r8sint\", TokenClass.keyword, \"r8sint\"),\n    r16uint: new TokenType(\"r16uint\", TokenClass.keyword, \"r16uint\"),\n    r16sint: new TokenType(\"r16sint\", TokenClass.keyword, \"r16sint\"),\n    r16float: new TokenType(\"r16float\", TokenClass.keyword, \"r16float\"),\n    rg8unorm: new TokenType(\"rg8unorm\", TokenClass.keyword, \"rg8unorm\"),\n    rg8snorm: new TokenType(\"rg8snorm\", TokenClass.keyword, \"rg8snorm\"),\n    rg8uint: new TokenType(\"rg8uint\", TokenClass.keyword, \"rg8uint\"),\n    rg8sint: new TokenType(\"rg8sint\", TokenClass.keyword, \"rg8sint\"),\n    r32uint: new TokenType(\"r32uint\", TokenClass.keyword, \"r32uint\"),\n    r32sint: new TokenType(\"r32sint\", TokenClass.keyword, \"r32sint\"),\n    r32float: new TokenType(\"r32float\", TokenClass.keyword, \"r32float\"),\n    rg16uint: new TokenType(\"rg16uint\", TokenClass.keyword, \"rg16uint\"),\n    rg16sint: new TokenType(\"rg16sint\", TokenClass.keyword, \"rg16sint\"),\n    rg16float: new TokenType(\"rg16float\", TokenClass.keyword, \"rg16float\"),\n    rgba8unorm: new TokenType(\"rgba8unorm\", TokenClass.keyword, \"rgba8unorm\"),\n    rgba8unorm_srgb: new TokenType(\"rgba8unorm_srgb\", TokenClass.keyword, \"rgba8unorm_srgb\"),\n    rgba8snorm: new TokenType(\"rgba8snorm\", TokenClass.keyword, \"rgba8snorm\"),\n    rgba8uint: new TokenType(\"rgba8uint\", TokenClass.keyword, \"rgba8uint\"),\n    rgba8sint: new TokenType(\"rgba8sint\", TokenClass.keyword, \"rgba8sint\"),\n    bgra8unorm: new TokenType(\"bgra8unorm\", TokenClass.keyword, \"bgra8unorm\"),\n    bgra8unorm_srgb: new TokenType(\"bgra8unorm_srgb\", TokenClass.keyword, \"bgra8unorm_srgb\"),\n    rgb10a2unorm: new TokenType(\"rgb10a2unorm\", TokenClass.keyword, \"rgb10a2unorm\"),\n    rg11b10float: new TokenType(\"rg11b10float\", TokenClass.keyword, \"rg11b10float\"),\n    rg32uint: new TokenType(\"rg32uint\", TokenClass.keyword, \"rg32uint\"),\n    rg32sint: new TokenType(\"rg32sint\", TokenClass.keyword, \"rg32sint\"),\n    rg32float: new TokenType(\"rg32float\", TokenClass.keyword, \"rg32float\"),\n    rgba16uint: new TokenType(\"rgba16uint\", TokenClass.keyword, \"rgba16uint\"),\n    rgba16sint: new TokenType(\"rgba16sint\", TokenClass.keyword, \"rgba16sint\"),\n    rgba16float: new TokenType(\"rgba16float\", TokenClass.keyword, \"rgba16float\"),\n    rgba32uint: new TokenType(\"rgba32uint\", TokenClass.keyword, \"rgba32uint\"),\n    rgba32sint: new TokenType(\"rgba32sint\", TokenClass.keyword, \"rgba32sint\"),\n    rgba32float: new TokenType(\"rgba32float\", TokenClass.keyword, \"rgba32float\"),\n    static_assert: new TokenType(\"static_assert\", TokenClass.keyword, \"static_assert\"),\n    // WGSL grammar has a few keywords that have different token names than the strings they\n    // represent. Aliasing them here.\n    /*int32: new TokenType(\"i32\", TokenClass.keyword, \"i32\"),\n        uint32: new TokenType(\"u32\", TokenClass.keyword, \"u32\"),\n        float32: new TokenType(\"f32\", TokenClass.keyword, \"f32\"),\n        pointer: new TokenType(\"ptr\", TokenClass.keyword, \"ptr\"),*/\n};\nTokenTypes.tokens = {\n    decimal_float_literal: new TokenType(\"decimal_float_literal\", TokenClass.token, /((-?[0-9]*\\.[0-9]+|-?[0-9]+\\.[0-9]*)((e|E)(\\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\\+|-)?[0-9]+f?)/),\n    hex_float_literal: new TokenType(\"hex_float_literal\", TokenClass.token, /-?0x((([0-9a-fA-F]*\\.[0-9a-fA-F]+|[0-9a-fA-F]+\\.[0-9a-fA-F]*)((p|P)(\\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\\+|-)?[0-9]+f?))/),\n    int_literal: new TokenType(\"int_literal\", TokenClass.token, /-?0x[0-9a-fA-F]+|0|-?[1-9][0-9]*/),\n    uint_literal: new TokenType(\"uint_literal\", TokenClass.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),\n    ident: new TokenType(\"ident\", TokenClass.token, /[a-zA-Z][0-9a-zA-Z_]*/),\n    and: new TokenType(\"and\", TokenClass.token, \"&\"),\n    and_and: new TokenType(\"and_and\", TokenClass.token, \"&&\"),\n    arrow: new TokenType(\"arrow \", TokenClass.token, \"->\"),\n    attr: new TokenType(\"attr\", TokenClass.token, \"@\"),\n    attr_left: new TokenType(\"attr_left\", TokenClass.token, \"[[\"),\n    attr_right: new TokenType(\"attr_right\", TokenClass.token, \"]]\"),\n    forward_slash: new TokenType(\"forward_slash\", TokenClass.token, \"/\"),\n    bang: new TokenType(\"bang\", TokenClass.token, \"!\"),\n    bracket_left: new TokenType(\"bracket_left\", TokenClass.token, \"[\"),\n    bracket_right: new TokenType(\"bracket_right\", TokenClass.token, \"]\"),\n    brace_left: new TokenType(\"brace_left\", TokenClass.token, \"{\"),\n    brace_right: new TokenType(\"brace_right\", TokenClass.token, \"}\"),\n    colon: new TokenType(\"colon\", TokenClass.token, \":\"),\n    comma: new TokenType(\"comma\", TokenClass.token, \",\"),\n    equal: new TokenType(\"equal\", TokenClass.token, \"=\"),\n    equal_equal: new TokenType(\"equal_equal\", TokenClass.token, \"==\"),\n    not_equal: new TokenType(\"not_equal\", TokenClass.token, \"!=\"),\n    greater_than: new TokenType(\"greater_than\", TokenClass.token, \">\"),\n    greater_than_equal: new TokenType(\"greater_than_equal\", TokenClass.token, \">=\"),\n    shift_right: new TokenType(\"shift_right\", TokenClass.token, \">>\"),\n    less_than: new TokenType(\"less_than\", TokenClass.token, \"<\"),\n    less_than_equal: new TokenType(\"less_than_equal\", TokenClass.token, \"<=\"),\n    shift_left: new TokenType(\"shift_left\", TokenClass.token, \"<<\"),\n    modulo: new TokenType(\"modulo\", TokenClass.token, \"%\"),\n    minus: new TokenType(\"minus\", TokenClass.token, \"-\"),\n    minus_minus: new TokenType(\"minus_minus\", TokenClass.token, \"--\"),\n    period: new TokenType(\"period\", TokenClass.token, \".\"),\n    plus: new TokenType(\"plus\", TokenClass.token, \"+\"),\n    plus_plus: new TokenType(\"plus_plus\", TokenClass.token, \"++\"),\n    or: new TokenType(\"or\", TokenClass.token, \"|\"),\n    or_or: new TokenType(\"or_or\", TokenClass.token, \"||\"),\n    paren_left: new TokenType(\"paren_left\", TokenClass.token, \"(\"),\n    paren_right: new TokenType(\"paren_right\", TokenClass.token, \")\"),\n    semicolon: new TokenType(\"semicolon\", TokenClass.token, \";\"),\n    star: new TokenType(\"star\", TokenClass.token, \"*\"),\n    tilde: new TokenType(\"tilde\", TokenClass.token, \"~\"),\n    underscore: new TokenType(\"underscore\", TokenClass.token, \"_\"),\n    xor: new TokenType(\"xor\", TokenClass.token, \"^\"),\n    plus_equal: new TokenType(\"plus_equal\", TokenClass.token, \"+=\"),\n    minus_equal: new TokenType(\"minus_equal\", TokenClass.token, \"-=\"),\n    times_equal: new TokenType(\"times_equal\", TokenClass.token, \"*=\"),\n    division_equal: new TokenType(\"division_equal\", TokenClass.token, \"/=\"),\n    modulo_equal: new TokenType(\"modulo_equal\", TokenClass.token, \"%=\"),\n    and_equal: new TokenType(\"and_equal\", TokenClass.token, \"&=\"),\n    or_equal: new TokenType(\"or_equal\", TokenClass.token, \"|=\"),\n    xor_equal: new TokenType(\"xor_equal\", TokenClass.token, \"^=\"),\n    shift_right_equal: new TokenType(\"shift_right_equal\", TokenClass.token, \">>=\"),\n    shift_left_equal: new TokenType(\"shift_left_equal\", TokenClass.token, \"<<=\"),\n};\nTokenTypes.storage_class = [\n    _a.keywords.function,\n    _a.keywords.private,\n    _a.keywords.workgroup,\n    _a.keywords.uniform,\n    _a.keywords.storage,\n];\nTokenTypes.access_mode = [\n    _a.keywords.read,\n    _a.keywords.write,\n    _a.keywords.read_write,\n];\nTokenTypes.sampler_type = [\n    _a.keywords.sampler,\n    _a.keywords.sampler_comparison,\n];\nTokenTypes.sampled_texture_type = [\n    _a.keywords.texture_1d,\n    _a.keywords.texture_2d,\n    _a.keywords.texture_2d_array,\n    _a.keywords.texture_3d,\n    _a.keywords.texture_cube,\n    _a.keywords.texture_cube_array,\n];\nTokenTypes.multisampled_texture_type = [\n    _a.keywords.texture_multisampled_2d,\n];\nTokenTypes.storage_texture_type = [\n    _a.keywords.texture_storage_1d,\n    _a.keywords.texture_storage_2d,\n    _a.keywords.texture_storage_2d_array,\n    _a.keywords.texture_storage_3d,\n];\nTokenTypes.depth_texture_type = [\n    _a.keywords.texture_depth_2d,\n    _a.keywords.texture_depth_2d_array,\n    _a.keywords.texture_depth_cube,\n    _a.keywords.texture_depth_cube_array,\n    _a.keywords.texture_depth_multisampled_2d,\n];\nTokenTypes.any_texture_type = [\n    ..._a.sampled_texture_type,\n    ..._a.multisampled_texture_type,\n    ..._a.storage_texture_type,\n    ..._a.depth_texture_type,\n];\nTokenTypes.texel_format = [\n    _a.keywords.r8unorm,\n    _a.keywords.r8snorm,\n    _a.keywords.r8uint,\n    _a.keywords.r8sint,\n    _a.keywords.r16uint,\n    _a.keywords.r16sint,\n    _a.keywords.r16float,\n    _a.keywords.rg8unorm,\n    _a.keywords.rg8snorm,\n    _a.keywords.rg8uint,\n    _a.keywords.rg8sint,\n    _a.keywords.r32uint,\n    _a.keywords.r32sint,\n    _a.keywords.r32float,\n    _a.keywords.rg16uint,\n    _a.keywords.rg16sint,\n    _a.keywords.rg16float,\n    _a.keywords.rgba8unorm,\n    _a.keywords.rgba8unorm_srgb,\n    _a.keywords.rgba8snorm,\n    _a.keywords.rgba8uint,\n    _a.keywords.rgba8sint,\n    _a.keywords.bgra8unorm,\n    _a.keywords.bgra8unorm_srgb,\n    _a.keywords.rgb10a2unorm,\n    _a.keywords.rg11b10float,\n    _a.keywords.rg32uint,\n    _a.keywords.rg32sint,\n    _a.keywords.rg32float,\n    _a.keywords.rgba16uint,\n    _a.keywords.rgba16sint,\n    _a.keywords.rgba16float,\n    _a.keywords.rgba32uint,\n    _a.keywords.rgba32sint,\n    _a.keywords.rgba32float,\n];\nTokenTypes.const_literal = [\n    _a.tokens.int_literal,\n    _a.tokens.uint_literal,\n    _a.tokens.decimal_float_literal,\n    _a.tokens.hex_float_literal,\n    _a.keywords.true,\n    _a.keywords.false,\n];\nTokenTypes.literal_or_ident = [\n    _a.tokens.ident,\n    _a.tokens.int_literal,\n    _a.tokens.uint_literal,\n    _a.tokens.decimal_float_literal,\n    _a.tokens.hex_float_literal,\n];\nTokenTypes.element_count_expression = [\n    _a.tokens.int_literal,\n    _a.tokens.uint_literal,\n    _a.tokens.ident,\n];\nTokenTypes.template_types = [\n    _a.keywords.vec2,\n    _a.keywords.vec3,\n    _a.keywords.vec4,\n    _a.keywords.mat2x2,\n    _a.keywords.mat2x3,\n    _a.keywords.mat2x4,\n    _a.keywords.mat3x2,\n    _a.keywords.mat3x3,\n    _a.keywords.mat3x4,\n    _a.keywords.mat4x2,\n    _a.keywords.mat4x3,\n    _a.keywords.mat4x4,\n    _a.keywords.atomic,\n    _a.keywords.bitcast,\n    ..._a.any_texture_type,\n];\n// The grammar calls out 'block', but attribute grammar is defined to use a 'ident'.\n// The attribute grammar should be ident | block.\nTokenTypes.attribute_name = [_a.tokens.ident, _a.keywords.block];\nTokenTypes.assignment_operators = [\n    _a.tokens.equal,\n    _a.tokens.plus_equal,\n    _a.tokens.minus_equal,\n    _a.tokens.times_equal,\n    _a.tokens.division_equal,\n    _a.tokens.modulo_equal,\n    _a.tokens.and_equal,\n    _a.tokens.or_equal,\n    _a.tokens.xor_equal,\n    _a.tokens.shift_right_equal,\n    _a.tokens.shift_left_equal,\n];\nTokenTypes.increment_operators = [\n    _a.tokens.plus_plus,\n    _a.tokens.minus_minus,\n];\n/// A token parsed by the WgslScanner.\nclass Token {\n    constructor(type, lexeme, line) {\n        this.type = type;\n        this.lexeme = lexeme;\n        this.line = line;\n    }\n    toString() {\n        return this.lexeme;\n    }\n}\n/// Lexical scanner for the WGSL language. This takes an input source text and generates a list\n/// of Token objects, which can then be fed into the WgslParser to generate an AST.\nclass WgslScanner {\n    constructor(source) {\n        this._tokens = [];\n        this._start = 0;\n        this._current = 0;\n        this._line = 1;\n        this._source = source !== null && source !== void 0 ? source : \"\";\n    }\n    /// Scan all tokens from the source.\n    scanTokens() {\n        while (!this._isAtEnd()) {\n            this._start = this._current;\n            if (!this.scanToken())\n                throw `Invalid syntax at line ${this._line}`;\n        }\n        this._tokens.push(new Token(TokenTypes.eof, \"\", this._line));\n        return this._tokens;\n    }\n    /// Scan a single token from the source.\n    scanToken() {\n        // Find the longest consecutive set of characters that match a rule.\n        let lexeme = this._advance();\n        // Skip line-feed, adding to the line counter.\n        if (lexeme == \"\\n\") {\n            this._line++;\n            return true;\n        }\n        // Skip whitespace\n        if (this._isWhitespace(lexeme)) {\n            return true;\n        }\n        if (lexeme == \"/\") {\n            // If it's a // comment, skip everything until the next line-feed.\n            if (this._peekAhead() == \"/\") {\n                while (lexeme != \"\\n\") {\n                    if (this._isAtEnd())\n                        return true;\n                    lexeme = this._advance();\n                }\n                // skip the linefeed\n                this._line++;\n                return true;\n            }\n            else if (this._peekAhead() == \"*\") {\n                // If it's a / * block comment, skip everything until the matching * /,\n                // allowing for nested block comments.\n                this._advance();\n                let commentLevel = 1;\n                while (commentLevel > 0) {\n                    if (this._isAtEnd())\n                        return true;\n                    lexeme = this._advance();\n                    if (lexeme == \"\\n\") {\n                        this._line++;\n                    }\n                    else if (lexeme == \"*\") {\n                        if (this._peekAhead() == \"/\") {\n                            this._advance();\n                            commentLevel--;\n                            if (commentLevel == 0) {\n                                return true;\n                            }\n                        }\n                    }\n                    else if (lexeme == \"/\") {\n                        if (this._peekAhead() == \"*\") {\n                            this._advance();\n                            commentLevel++;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        let matchType = TokenTypes.none;\n        for (;;) {\n            let matchedType = this._findType(lexeme);\n            // The exception to \"longest lexeme\" rule is '>>'. In the case of 1>>2, it's a\n            // shift_right.\n            // In the case of array<vec4<f32>>, it's two greater_than's (one to close the vec4,\n            // and one to close the array).\n            // I don't know of a great way to resolve this, so '>>' is special-cased and if\n            // there was a less_than up to some number of tokens previously, and the token prior to\n            // that is a keyword that requires a '<', then it will be split into two greater_than's;\n            // otherwise it's a shift_right.\n            if (lexeme == \">\" && this._peekAhead() == \">\") {\n                let foundLessThan = false;\n                let ti = this._tokens.length - 1;\n                for (let count = 0; count < 4 && ti >= 0; ++count, --ti) {\n                    if (this._tokens[ti].type === TokenTypes.tokens.less_than) {\n                        if (ti > 0 &&\n                            TokenTypes.template_types.indexOf(this._tokens[ti - 1].type) != -1) {\n                            foundLessThan = true;\n                        }\n                        break;\n                    }\n                }\n                // If there was a less_than in the recent token history, then this is probably a\n                // greater_than.\n                if (foundLessThan) {\n                    this._addToken(matchedType);\n                    return true;\n                }\n            }\n            // The current lexeme may not match any rule, but some token types may be invalid for\n            // part of the string but valid after a few more characters.\n            // For example, 0x.5 is a hex_float_literal. But as it's being scanned,\n            // \"0\" is a int_literal, then \"0x\" is invalid. If we stopped there, it would return\n            // the int_literal \"0\", but that's incorrect. So if we look forward a few characters,\n            // we'd get \"0x.\", which is still invalid, followed by \"0x.5\" which is the correct\n            // hex_float_literal. So that means if we hit an non-matching string, we should look\n            // ahead up to two characters to see if the string starts matching a valid rule again.\n            if (matchedType === TokenTypes.none) {\n                let lookAheadLexeme = lexeme;\n                let lookAhead = 0;\n                const maxLookAhead = 2;\n                for (let li = 0; li < maxLookAhead; ++li) {\n                    lookAheadLexeme += this._peekAhead(li);\n                    matchedType = this._findType(lookAheadLexeme);\n                    if (matchedType !== TokenTypes.none) {\n                        lookAhead = li;\n                        break;\n                    }\n                }\n                if (matchedType === TokenTypes.none) {\n                    if (matchType === TokenTypes.none)\n                        return false;\n                    this._current--;\n                    this._addToken(matchType);\n                    return true;\n                }\n                lexeme = lookAheadLexeme;\n                this._current += lookAhead + 1;\n            }\n            matchType = matchedType;\n            if (this._isAtEnd())\n                break;\n            lexeme += this._advance();\n        }\n        // We got to the end of the input stream. Then the token we've ready so far is it.\n        if (matchType === TokenTypes.none)\n            return false;\n        this._addToken(matchType);\n        return true;\n    }\n    _findType(lexeme) {\n        for (const name in TokenTypes.keywords) {\n            const type = TokenTypes.keywords[name];\n            if (this._match(lexeme, type.rule)) {\n                return type;\n            }\n        }\n        for (const name in TokenTypes.tokens) {\n            const type = TokenTypes.tokens[name];\n            if (this._match(lexeme, type.rule)) {\n                return type;\n            }\n        }\n        return TokenTypes.none;\n    }\n    _match(lexeme, rule) {\n        if (typeof rule === \"string\") {\n            if (rule == lexeme) {\n                return true;\n            }\n        }\n        else {\n            // regex\n            const match = rule.exec(lexeme);\n            if (match && match.index == 0 && match[0] == lexeme)\n                return true;\n        }\n        return false;\n    }\n    _isAtEnd() {\n        return this._current >= this._source.length;\n    }\n    _isWhitespace(c) {\n        return c == \" \" || c == \"\\t\" || c == \"\\r\";\n    }\n    _advance(amount = 0) {\n        let c = this._source[this._current];\n        amount = amount || 0;\n        amount++;\n        this._current += amount;\n        return c;\n    }\n    _peekAhead(offset = 0) {\n        offset = offset || 0;\n        if (this._current + offset >= this._source.length)\n            return \"\\0\";\n        return this._source[this._current + offset];\n    }\n    _addToken(type) {\n        const text = this._source.substring(this._start, this._current);\n        this._tokens.push(new Token(type, text, this._line));\n    }\n}\n\n/**\n * @author Brendan Duncan / https://github.com/brendan-duncan\n */\n/// Parse a sequence of tokens from the WgslScanner into an Abstract Syntax Tree (AST).\nclass WgslParser {\n    constructor() {\n        this._tokens = [];\n        this._current = 0;\n    }\n    parse(tokensOrCode) {\n        this._initialize(tokensOrCode);\n        let statements = [];\n        while (!this._isAtEnd()) {\n            const statement = this._global_decl_or_directive();\n            if (!statement)\n                break;\n            statements.push(statement);\n        }\n        return statements;\n    }\n    _initialize(tokensOrCode) {\n        if (tokensOrCode) {\n            if (typeof tokensOrCode == \"string\") {\n                const scanner = new WgslScanner(tokensOrCode);\n                this._tokens = scanner.scanTokens();\n            }\n            else {\n                this._tokens = tokensOrCode;\n            }\n        }\n        else {\n            this._tokens = [];\n        }\n        this._current = 0;\n    }\n    _error(token, message) {\n        console.error(token, message);\n        return {\n            token,\n            message,\n            toString: function () {\n                return `${message}`;\n            },\n        };\n    }\n    _isAtEnd() {\n        return (this._current >= this._tokens.length ||\n            this._peek().type == TokenTypes.eof);\n    }\n    _match(types) {\n        if (types instanceof TokenType) {\n            if (this._check(types)) {\n                this._advance();\n                return true;\n            }\n            return false;\n        }\n        for (let i = 0, l = types.length; i < l; ++i) {\n            const type = types[i];\n            if (this._check(type)) {\n                this._advance();\n                return true;\n            }\n        }\n        return false;\n    }\n    _consume(types, message) {\n        if (this._check(types))\n            return this._advance();\n        throw this._error(this._peek(), message);\n    }\n    _check(types) {\n        if (this._isAtEnd())\n            return false;\n        const tk = this._peek();\n        if (types instanceof Array) {\n            let t = tk.type;\n            let index = types.indexOf(t);\n            return index != -1;\n        }\n        return tk.type == types;\n    }\n    _advance() {\n        if (!this._isAtEnd())\n            this._current++;\n        return this._previous();\n    }\n    _peek() {\n        return this._tokens[this._current];\n    }\n    _previous() {\n        return this._tokens[this._current - 1];\n    }\n    _global_decl_or_directive() {\n        // semicolon\n        // global_variable_decl semicolon\n        // global_constant_decl semicolon\n        // type_alias semicolon\n        // struct_decl\n        // function_decl\n        // enable_directive\n        // Ignore any stand-alone semicolons\n        while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())\n            ;\n        if (this._match(TokenTypes.keywords.type)) {\n            const type = this._type_alias();\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\n            return type;\n        }\n        if (this._match(TokenTypes.keywords.enable)) {\n            const enable = this._enable_directive();\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\n            return enable;\n        }\n        // The following statements have an optional attribute*\n        const attrs = this._attribute();\n        if (this._check(TokenTypes.keywords.var)) {\n            const _var = this._global_variable_decl();\n            if (_var != null)\n                _var.attributes = attrs;\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\n            return _var;\n        }\n        if (this._check(TokenTypes.keywords.let)) {\n            const _let = this._global_constant_decl();\n            if (_let != null)\n                _let.attributes = attrs;\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\n            return _let;\n        }\n        if (this._check(TokenTypes.keywords.struct)) {\n            const _struct = this._struct_decl();\n            if (_struct != null)\n                _struct.attributes = attrs;\n            return _struct;\n        }\n        if (this._check(TokenTypes.keywords.fn)) {\n            const _fn = this._function_decl();\n            if (_fn != null)\n                _fn.attributes = attrs;\n            return _fn;\n        }\n        return null;\n    }\n    _function_decl() {\n        // attribute* function_header compound_statement\n        // function_header: fn ident paren_left param_list? paren_right (arrow attribute* type_decl)?\n        if (!this._match(TokenTypes.keywords.fn))\n            return null;\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected function name.\").toString();\n        this._consume(TokenTypes.tokens.paren_left, \"Expected '(' for function arguments.\");\n        const args = [];\n        if (!this._check(TokenTypes.tokens.paren_right)) {\n            do {\n                if (this._check(TokenTypes.tokens.paren_right))\n                    break;\n                const argAttrs = this._attribute();\n                const name = this._consume(TokenTypes.tokens.ident, \"Expected argument name.\").toString();\n                this._consume(TokenTypes.tokens.colon, \"Expected ':' for argument type.\");\n                const typeAttrs = this._attribute();\n                const type = this._type_decl();\n                if (type != null) {\n                    type.attributes = typeAttrs;\n                    args.push(new Argument(name, type, argAttrs));\n                }\n            } while (this._match(TokenTypes.tokens.comma));\n        }\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')' after function arguments.\");\n        let _return = null;\n        if (this._match(TokenTypes.tokens.arrow)) {\n            const attrs = this._attribute();\n            _return = this._type_decl();\n            if (_return != null)\n                _return.attributes = attrs;\n        }\n        const body = this._compound_statement();\n        return new Function(name, args, _return, body);\n    }\n    _compound_statement() {\n        // brace_left statement* brace_right\n        const statements = [];\n        this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for block.\");\n        while (!this._check(TokenTypes.tokens.brace_right)) {\n            const statement = this._statement();\n            if (statement !== null)\n                statements.push(statement);\n        }\n        this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for block.\");\n        return statements;\n    }\n    _statement() {\n        // semicolon\n        // return_statement semicolon\n        // if_statement\n        // switch_statement\n        // loop_statement\n        // for_statement\n        // func_call_statement semicolon\n        // variable_statement semicolon\n        // break_statement semicolon\n        // continue_statement semicolon\n        // discard semicolon\n        // assignment_statement semicolon\n        // compound_statement\n        // increment_statement semicolon\n        // decrement_statement semicolon\n        // static_assert_statement semicolon\n        // Ignore any stand-alone semicolons\n        while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())\n            ;\n        if (this._check(TokenTypes.keywords.if))\n            return this._if_statement();\n        if (this._check(TokenTypes.keywords.switch))\n            return this._switch_statement();\n        if (this._check(TokenTypes.keywords.loop))\n            return this._loop_statement();\n        if (this._check(TokenTypes.keywords.for))\n            return this._for_statement();\n        if (this._check(TokenTypes.keywords.while))\n            return this._while_statement();\n        if (this._check(TokenTypes.keywords.static_assert))\n            return this._static_assert_statement();\n        if (this._check(TokenTypes.tokens.brace_left))\n            return this._compound_statement();\n        let result = null;\n        if (this._check(TokenTypes.keywords.return))\n            result = this._return_statement();\n        else if (this._check([\n            TokenTypes.keywords.var,\n            TokenTypes.keywords.let,\n            TokenTypes.keywords.const,\n        ]))\n            result = this._variable_statement();\n        else if (this._match(TokenTypes.keywords.discard))\n            result = new Discard();\n        else if (this._match(TokenTypes.keywords.break))\n            result = new Break();\n        else if (this._match(TokenTypes.keywords.continue))\n            result = new Continue();\n        else\n            result =\n                this._increment_decrement_statement() ||\n                    this._func_call_statement() ||\n                    this._assignment_statement();\n        if (result != null)\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';' after statement.\");\n        return result;\n    }\n    _static_assert_statement() {\n        if (!this._match(TokenTypes.keywords.static_assert))\n            return null;\n        let expression = this._optional_paren_expression();\n        return new StaticAssert(expression);\n    }\n    _while_statement() {\n        if (!this._match(TokenTypes.keywords.while))\n            return null;\n        let condition = this._optional_paren_expression();\n        const block = this._compound_statement();\n        return new While(condition, block);\n    }\n    _for_statement() {\n        // for paren_left for_header paren_right compound_statement\n        if (!this._match(TokenTypes.keywords.for))\n            return null;\n        this._consume(TokenTypes.tokens.paren_left, \"Expected '('.\");\n        // for_header: (variable_statement assignment_statement func_call_statement)? semicolon short_circuit_or_expression? semicolon (assignment_statement func_call_statement)?\n        const init = !this._check(TokenTypes.tokens.semicolon)\n            ? this._for_init()\n            : null;\n        this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\n        const condition = !this._check(TokenTypes.tokens.semicolon)\n            ? this._short_circuit_or_expression()\n            : null;\n        this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\n        const increment = !this._check(TokenTypes.tokens.paren_right)\n            ? this._for_increment()\n            : null;\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')'.\");\n        const body = this._compound_statement();\n        return new For(init, condition, increment, body);\n    }\n    _for_init() {\n        // (variable_statement assignment_statement func_call_statement)?\n        return (this._variable_statement() ||\n            this._func_call_statement() ||\n            this._assignment_statement());\n    }\n    _for_increment() {\n        // (assignment_statement func_call_statement increment_statement)?\n        return (this._func_call_statement() ||\n            this._increment_decrement_statement() ||\n            this._assignment_statement());\n    }\n    _variable_statement() {\n        // variable_decl\n        // variable_decl equal short_circuit_or_expression\n        // let (ident variable_ident_decl) equal short_circuit_or_expression\n        // const (ident variable_ident_decl) equal short_circuit_or_expression\n        if (this._check(TokenTypes.keywords.var)) {\n            const _var = this._variable_decl();\n            if (_var === null)\n                throw this._error(this._peek(), \"Variable declaration expected.\");\n            let value = null;\n            if (this._match(TokenTypes.tokens.equal))\n                value = this._short_circuit_or_expression();\n            return new Var(_var.name, _var.type, _var.storage, _var.access, value);\n        }\n        if (this._match(TokenTypes.keywords.let)) {\n            const name = this._consume(TokenTypes.tokens.ident, \"Expected name for let.\").toString();\n            let type = null;\n            if (this._match(TokenTypes.tokens.colon)) {\n                const typeAttrs = this._attribute();\n                type = this._type_decl();\n                if (type != null)\n                    type.attributes = typeAttrs;\n            }\n            this._consume(TokenTypes.tokens.equal, \"Expected '=' for let.\");\n            const value = this._short_circuit_or_expression();\n            return new Let(name, type, null, null, value);\n        }\n        if (this._match(TokenTypes.keywords.const)) {\n            const name = this._consume(TokenTypes.tokens.ident, \"Expected name for const.\").toString();\n            let type = null;\n            if (this._match(TokenTypes.tokens.colon)) {\n                const typeAttrs = this._attribute();\n                type = this._type_decl();\n                if (type != null)\n                    type.attributes = typeAttrs;\n            }\n            this._consume(TokenTypes.tokens.equal, \"Expected '=' for const.\");\n            const value = this._short_circuit_or_expression();\n            return new Const(name, type, null, null, value);\n        }\n        return null;\n    }\n    _increment_decrement_statement() {\n        const savedPos = this._current;\n        const _var = this._unary_expression();\n        if (_var == null)\n            return null;\n        if (!this._check(TokenTypes.increment_operators)) {\n            this._current = savedPos;\n            return null;\n        }\n        const token = this._consume(TokenTypes.increment_operators, \"Expected increment operator\");\n        return new Increment(token.type === TokenTypes.tokens.plus_plus\n            ? IncrementOperator.increment\n            : IncrementOperator.decrement, _var);\n    }\n    _assignment_statement() {\n        // (unary_expression underscore) equal short_circuit_or_expression\n        let _var = null;\n        if (this._check(TokenTypes.tokens.brace_right))\n            return null;\n        let isUnderscore = this._match(TokenTypes.tokens.underscore);\n        if (!isUnderscore)\n            _var = this._unary_expression();\n        if (!isUnderscore && _var == null)\n            return null;\n        const type = this._consume(TokenTypes.assignment_operators, \"Expected assignment operator.\");\n        const value = this._short_circuit_or_expression();\n        return new Assign(AssignOperator.parse(type.lexeme), _var, value);\n    }\n    _func_call_statement() {\n        // ident argument_expression_list\n        if (!this._check(TokenTypes.tokens.ident))\n            return null;\n        const savedPos = this._current;\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected function name.\");\n        const args = this._argument_expression_list();\n        if (args === null) {\n            this._current = savedPos;\n            return null;\n        }\n        return new Call(name.lexeme, args);\n    }\n    _loop_statement() {\n        // loop brace_left statement* continuing_statement? brace_right\n        if (!this._match(TokenTypes.keywords.loop))\n            return null;\n        this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for loop.\");\n        // statement*\n        const statements = [];\n        let statement = this._statement();\n        while (statement !== null) {\n            if (statement instanceof (Array)) {\n                for (let s of statement) {\n                    statements.push(s);\n                }\n            }\n            else {\n                statements.push(statement);\n            }\n            statement = this._statement();\n        }\n        // continuing_statement: continuing compound_statement\n        let continuing = null;\n        if (this._match(TokenTypes.keywords.continuing))\n            continuing = this._compound_statement();\n        this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for loop.\");\n        return new Loop(statements, continuing);\n    }\n    _switch_statement() {\n        // switch optional_paren_expression brace_left switch_body+ brace_right\n        if (!this._match(TokenTypes.keywords.switch))\n            return null;\n        const condition = this._optional_paren_expression();\n        this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for switch.\");\n        const body = this._switch_body();\n        if (body == null || body.length == 0)\n            throw this._error(this._previous(), \"Expected 'case' or 'default'.\");\n        this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for switch.\");\n        return new Switch(condition, body);\n    }\n    _switch_body() {\n        // case case_selectors colon brace_left case_body? brace_right\n        // default colon brace_left case_body? brace_right\n        const cases = [];\n        if (this._match(TokenTypes.keywords.case)) {\n            const selector = this._case_selectors();\n            this._consume(TokenTypes.tokens.colon, \"Exected ':' for switch case.\");\n            this._consume(TokenTypes.tokens.brace_left, \"Exected '{' for switch case.\");\n            const body = this._case_body();\n            this._consume(TokenTypes.tokens.brace_right, \"Exected '}' for switch case.\");\n            cases.push(new Case(selector, body));\n        }\n        if (this._match(TokenTypes.keywords.default)) {\n            this._consume(TokenTypes.tokens.colon, \"Exected ':' for switch default.\");\n            this._consume(TokenTypes.tokens.brace_left, \"Exected '{' for switch default.\");\n            const body = this._case_body();\n            this._consume(TokenTypes.tokens.brace_right, \"Exected '}' for switch default.\");\n            cases.push(new Default(body));\n        }\n        if (this._check([TokenTypes.keywords.default, TokenTypes.keywords.case])) {\n            const _cases = this._switch_body();\n            cases.push(_cases[0]);\n        }\n        return cases;\n    }\n    _case_selectors() {\n        // const_literal (comma const_literal)* comma?\n        const selectors = [\n            this._consume(TokenTypes.const_literal, \"Expected constant literal\").toString(),\n        ];\n        while (this._match(TokenTypes.tokens.comma)) {\n            selectors.push(this._consume(TokenTypes.const_literal, \"Expected constant literal\").toString());\n        }\n        return selectors;\n    }\n    _case_body() {\n        // statement case_body?\n        // fallthrough semicolon\n        if (this._match(TokenTypes.keywords.fallthrough)) {\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\n            return [];\n        }\n        let statement = this._statement();\n        if (statement == null)\n            return [];\n        if (!(statement instanceof Array)) {\n            statement = [statement];\n        }\n        const nextStatement = this._case_body();\n        if (nextStatement.length == 0)\n            return statement;\n        return [...statement, nextStatement[0]];\n    }\n    _if_statement() {\n        // if optional_paren_expression compound_statement elseif_statement? else_statement?\n        if (!this._match(TokenTypes.keywords.if))\n            return null;\n        const condition = this._optional_paren_expression();\n        const block = this._compound_statement();\n        let elseif = null;\n        if (this._match(TokenTypes.keywords.elseif))\n            elseif = this._elseif_statement();\n        let _else = null;\n        if (this._match(TokenTypes.keywords.else))\n            _else = this._compound_statement();\n        return new If(condition, block, elseif, _else);\n    }\n    _elseif_statement() {\n        // else_if optional_paren_expression compound_statement elseif_statement?\n        const elseif = [];\n        const condition = this._optional_paren_expression();\n        const block = this._compound_statement();\n        elseif.push(new ElseIf(condition, block));\n        if (this._match(TokenTypes.keywords.elseif))\n            elseif.push(this._elseif_statement()[0]);\n        return elseif;\n    }\n    _return_statement() {\n        // return short_circuit_or_expression?\n        if (!this._match(TokenTypes.keywords.return))\n            return null;\n        const value = this._short_circuit_or_expression();\n        return new Return(value);\n    }\n    _short_circuit_or_expression() {\n        // short_circuit_and_expression\n        // short_circuit_or_expression or_or short_circuit_and_expression\n        let expr = this._short_circuit_and_expr();\n        while (this._match(TokenTypes.tokens.or_or)) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._short_circuit_and_expr());\n        }\n        return expr;\n    }\n    _short_circuit_and_expr() {\n        // inclusive_or_expression\n        // short_circuit_and_expression and_and inclusive_or_expression\n        let expr = this._inclusive_or_expression();\n        while (this._match(TokenTypes.tokens.and_and)) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._inclusive_or_expression());\n        }\n        return expr;\n    }\n    _inclusive_or_expression() {\n        // exclusive_or_expression\n        // inclusive_or_expression or exclusive_or_expression\n        let expr = this._exclusive_or_expression();\n        while (this._match(TokenTypes.tokens.or)) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._exclusive_or_expression());\n        }\n        return expr;\n    }\n    _exclusive_or_expression() {\n        // and_expression\n        // exclusive_or_expression xor and_expression\n        let expr = this._and_expression();\n        while (this._match(TokenTypes.tokens.xor)) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._and_expression());\n        }\n        return expr;\n    }\n    _and_expression() {\n        // equality_expression\n        // and_expression and equality_expression\n        let expr = this._equality_expression();\n        while (this._match(TokenTypes.tokens.and)) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._equality_expression());\n        }\n        return expr;\n    }\n    _equality_expression() {\n        // relational_expression\n        // relational_expression equal_equal relational_expression\n        // relational_expression not_equal relational_expression\n        const expr = this._relational_expression();\n        if (this._match([TokenTypes.tokens.equal_equal, TokenTypes.tokens.not_equal])) {\n            return new BinaryOperator(this._previous().toString(), expr, this._relational_expression());\n        }\n        return expr;\n    }\n    _relational_expression() {\n        // shift_expression\n        // relational_expression less_than shift_expression\n        // relational_expression greater_than shift_expression\n        // relational_expression less_than_equal shift_expression\n        // relational_expression greater_than_equal shift_expression\n        let expr = this._shift_expression();\n        while (this._match([\n            TokenTypes.tokens.less_than,\n            TokenTypes.tokens.greater_than,\n            TokenTypes.tokens.less_than_equal,\n            TokenTypes.tokens.greater_than_equal,\n        ])) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._shift_expression());\n        }\n        return expr;\n    }\n    _shift_expression() {\n        // additive_expression\n        // shift_expression shift_left additive_expression\n        // shift_expression shift_right additive_expression\n        let expr = this._additive_expression();\n        while (this._match([TokenTypes.tokens.shift_left, TokenTypes.tokens.shift_right])) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._additive_expression());\n        }\n        return expr;\n    }\n    _additive_expression() {\n        // multiplicative_expression\n        // additive_expression plus multiplicative_expression\n        // additive_expression minus multiplicative_expression\n        let expr = this._multiplicative_expression();\n        while (this._match([TokenTypes.tokens.plus, TokenTypes.tokens.minus])) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._multiplicative_expression());\n        }\n        return expr;\n    }\n    _multiplicative_expression() {\n        // unary_expression\n        // multiplicative_expression star unary_expression\n        // multiplicative_expression forward_slash unary_expression\n        // multiplicative_expression modulo unary_expression\n        let expr = this._unary_expression();\n        while (this._match([\n            TokenTypes.tokens.star,\n            TokenTypes.tokens.forward_slash,\n            TokenTypes.tokens.modulo,\n        ])) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._unary_expression());\n        }\n        return expr;\n    }\n    _unary_expression() {\n        // singular_expression\n        // minus unary_expression\n        // bang unary_expression\n        // tilde unary_expression\n        // star unary_expression\n        // and unary_expression\n        if (this._match([\n            TokenTypes.tokens.minus,\n            TokenTypes.tokens.bang,\n            TokenTypes.tokens.tilde,\n            TokenTypes.tokens.star,\n            TokenTypes.tokens.and,\n        ])) {\n            return new UnaryOperator(this._previous().toString(), this._unary_expression());\n        }\n        return this._singular_expression();\n    }\n    _singular_expression() {\n        // primary_expression postfix_expression ?\n        const expr = this._primary_expression();\n        const p = this._postfix_expression();\n        if (p)\n            expr.postfix = p;\n        return expr;\n    }\n    _postfix_expression() {\n        // bracket_left short_circuit_or_expression bracket_right postfix_expression?\n        if (this._match(TokenTypes.tokens.bracket_left)) {\n            const expr = this._short_circuit_or_expression();\n            this._consume(TokenTypes.tokens.bracket_right, \"Expected ']'.\");\n            const p = this._postfix_expression();\n            if (p)\n                expr.postfix = p;\n            return expr;\n        }\n        // period ident postfix_expression?\n        if (this._match(TokenTypes.tokens.period)) {\n            const name = this._consume(TokenTypes.tokens.ident, \"Expected member name.\");\n            const p = this._postfix_expression();\n            const expr = new StringExpr(name.lexeme);\n            if (p)\n                expr.postfix = p;\n            return expr;\n        }\n        return null;\n    }\n    _primary_expression() {\n        // ident argument_expression_list?\n        if (this._match(TokenTypes.tokens.ident)) {\n            const name = this._previous().toString();\n            if (this._check(TokenTypes.tokens.paren_left)) {\n                const args = this._argument_expression_list();\n                return new CallExpr(name, args);\n            }\n            return new VariableExpr(name);\n        }\n        // const_literal\n        if (this._match(TokenTypes.const_literal)) {\n            return new LiteralExpr(this._previous().toString());\n        }\n        // paren_expression\n        if (this._check(TokenTypes.tokens.paren_left)) {\n            return this._paren_expression();\n        }\n        // bitcast less_than type_decl greater_than paren_expression\n        if (this._match(TokenTypes.keywords.bitcast)) {\n            this._consume(TokenTypes.tokens.less_than, \"Expected '<'.\");\n            const type = this._type_decl();\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>'.\");\n            const value = this._paren_expression();\n            return new BitcastExpr(type, value);\n        }\n        // type_decl argument_expression_list\n        const type = this._type_decl();\n        const args = this._argument_expression_list();\n        return new TypecastExpr(type, args);\n    }\n    _argument_expression_list() {\n        // paren_left ((short_circuit_or_expression comma)* short_circuit_or_expression comma?)? paren_right\n        if (!this._match(TokenTypes.tokens.paren_left))\n            return null;\n        const args = [];\n        do {\n            if (this._check(TokenTypes.tokens.paren_right))\n                break;\n            const arg = this._short_circuit_or_expression();\n            args.push(arg);\n        } while (this._match(TokenTypes.tokens.comma));\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')' for agument list\");\n        return args;\n    }\n    _optional_paren_expression() {\n        // [paren_left] short_circuit_or_expression [paren_right]\n        this._match(TokenTypes.tokens.paren_left);\n        const expr = this._short_circuit_or_expression();\n        this._match(TokenTypes.tokens.paren_right);\n        return new GroupingExpr([expr]);\n    }\n    _paren_expression() {\n        // paren_left short_circuit_or_expression paren_right\n        this._consume(TokenTypes.tokens.paren_left, \"Expected '('.\");\n        const expr = this._short_circuit_or_expression();\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')'.\");\n        return new GroupingExpr([expr]);\n    }\n    _struct_decl() {\n        // attribute* struct ident struct_body_decl\n        if (!this._match(TokenTypes.keywords.struct))\n            return null;\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected name for struct.\").toString();\n        // struct_body_decl: brace_left (struct_member comma)* struct_member comma? brace_right\n        this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for struct body.\");\n        const members = [];\n        while (!this._check(TokenTypes.tokens.brace_right)) {\n            // struct_member: attribute* variable_ident_decl\n            const memberAttrs = this._attribute();\n            const memberName = this._consume(TokenTypes.tokens.ident, \"Expected variable name.\").toString();\n            this._consume(TokenTypes.tokens.colon, \"Expected ':' for struct member type.\");\n            const typeAttrs = this._attribute();\n            const memberType = this._type_decl();\n            if (memberType != null)\n                memberType.attributes = typeAttrs;\n            if (!this._check(TokenTypes.tokens.brace_right))\n                this._consume(TokenTypes.tokens.comma, \"Expected ',' for struct member.\");\n            else\n                this._match(TokenTypes.tokens.comma); // trailing comma optional.\n            members.push(new Member(memberName, memberType, memberAttrs));\n        }\n        this._consume(TokenTypes.tokens.brace_right, \"Expected '}' after struct body.\");\n        return new Struct(name, members);\n    }\n    _global_variable_decl() {\n        // attribute* variable_decl (equal const_expression)?\n        const _var = this._variable_decl();\n        if (_var && this._match(TokenTypes.tokens.equal))\n            _var.value = this._const_expression();\n        return _var;\n    }\n    _global_constant_decl() {\n        // attribute* let (ident variable_ident_decl) global_const_initializer?\n        if (!this._match(TokenTypes.keywords.let))\n            return null;\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected variable name\");\n        let type = null;\n        if (this._match(TokenTypes.tokens.colon)) {\n            const attrs = this._attribute();\n            type = this._type_decl();\n            if (type != null)\n                type.attributes = attrs;\n        }\n        let value = null;\n        if (this._match(TokenTypes.tokens.equal)) {\n            value = this._const_expression();\n        }\n        return new Let(name.toString(), type, \"\", \"\", value);\n    }\n    _const_expression() {\n        // type_decl paren_left ((const_expression comma)* const_expression comma?)? paren_right\n        // const_literal\n        if (this._match(TokenTypes.const_literal))\n            return new StringExpr(this._previous().toString());\n        const type = this._type_decl();\n        this._consume(TokenTypes.tokens.paren_left, \"Expected '('.\");\n        let args = [];\n        while (!this._check(TokenTypes.tokens.paren_right)) {\n            args.push(this._const_expression());\n            if (!this._check(TokenTypes.tokens.comma))\n                break;\n            this._advance();\n        }\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')'.\");\n        return new CreateExpr(type, args);\n    }\n    _variable_decl() {\n        // var variable_qualifier? (ident variable_ident_decl)\n        if (!this._match(TokenTypes.keywords.var))\n            return null;\n        // variable_qualifier: less_than storage_class (comma access_mode)? greater_than\n        let storage = \"\";\n        let access = \"\";\n        if (this._match(TokenTypes.tokens.less_than)) {\n            storage = this._consume(TokenTypes.storage_class, \"Expected storage_class.\").toString();\n            if (this._match(TokenTypes.tokens.comma))\n                access = this._consume(TokenTypes.access_mode, \"Expected access_mode.\").toString();\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>'.\");\n        }\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected variable name\");\n        let type = null;\n        if (this._match(TokenTypes.tokens.colon)) {\n            const attrs = this._attribute();\n            type = this._type_decl();\n            if (type != null)\n                type.attributes = attrs;\n        }\n        return new Var(name.toString(), type, storage, access, null);\n    }\n    _enable_directive() {\n        // enable ident semicolon\n        const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\n        return new Enable(name.toString());\n    }\n    _type_alias() {\n        // type ident equal type_decl\n        const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\n        this._consume(TokenTypes.tokens.equal, \"Expected '=' for type alias.\");\n        const alias = this._type_decl();\n        if (alias === null) {\n            throw this._error(this._peek(), \"Expected Type for Alias.\");\n        }\n        return new Alias(name.toString(), alias);\n    }\n    _type_decl() {\n        // ident\n        // bool\n        // float32\n        // int32\n        // uint32\n        // vec2 less_than type_decl greater_than\n        // vec3 less_than type_decl greater_than\n        // vec4 less_than type_decl greater_than\n        // mat2x2 less_than type_decl greater_than\n        // mat2x3 less_than type_decl greater_than\n        // mat2x4 less_than type_decl greater_than\n        // mat3x2 less_than type_decl greater_than\n        // mat3x3 less_than type_decl greater_than\n        // mat3x4 less_than type_decl greater_than\n        // mat4x2 less_than type_decl greater_than\n        // mat4x3 less_than type_decl greater_than\n        // mat4x4 less_than type_decl greater_than\n        // atomic less_than type_decl greater_than\n        // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\n        // array_type_decl\n        // texture_sampler_types\n        if (this._check([\n            TokenTypes.tokens.ident,\n            ...TokenTypes.texel_format,\n            TokenTypes.keywords.bool,\n            TokenTypes.keywords.f32,\n            TokenTypes.keywords.i32,\n            TokenTypes.keywords.u32,\n        ])) {\n            const type = this._advance();\n            return new Type(type.toString());\n        }\n        if (this._check(TokenTypes.template_types)) {\n            let type = this._advance().toString();\n            let format = null;\n            let access = null;\n            if (this._match(TokenTypes.tokens.less_than)) {\n                format = this._type_decl();\n                access = null;\n                if (this._match(TokenTypes.tokens.comma))\n                    access = this._consume(TokenTypes.access_mode, \"Expected access_mode for pointer\").toString();\n                this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for type.\");\n            }\n            return new TemplateType(type, format, access);\n        }\n        // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\n        if (this._match(TokenTypes.keywords.ptr)) {\n            let pointer = this._previous().toString();\n            this._consume(TokenTypes.tokens.less_than, \"Expected '<' for pointer.\");\n            const storage = this._consume(TokenTypes.storage_class, \"Expected storage_class for pointer\");\n            this._consume(TokenTypes.tokens.comma, \"Expected ',' for pointer.\");\n            const decl = this._type_decl();\n            let access = null;\n            if (this._match(TokenTypes.tokens.comma))\n                access = this._consume(TokenTypes.access_mode, \"Expected access_mode for pointer\").toString();\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for pointer.\");\n            return new PointerType(pointer, storage.toString(), decl, access);\n        }\n        // texture_sampler_types\n        let type = this._texture_sampler_types();\n        if (type)\n            return type;\n        // The following type_decl's have an optional attribyte_list*\n        const attrs = this._attribute();\n        // attribute* array less_than type_decl (comma element_count_expression)? greater_than\n        if (this._match(TokenTypes.keywords.array)) {\n            const array = this._previous();\n            this._consume(TokenTypes.tokens.less_than, \"Expected '<' for array type.\");\n            const format = this._type_decl();\n            let count = \"\";\n            if (this._match(TokenTypes.tokens.comma))\n                count = this._consume(TokenTypes.element_count_expression, \"Expected element_count for array.\").toString();\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for array.\");\n            let countInt = count ? parseInt(count) : 0;\n            return new ArrayType(array.toString(), attrs, format, countInt);\n        }\n        return null;\n    }\n    _texture_sampler_types() {\n        // sampler_type\n        if (this._match(TokenTypes.sampler_type))\n            return new SamplerType(this._previous().toString(), null, null);\n        // depth_texture_type\n        if (this._match(TokenTypes.depth_texture_type))\n            return new SamplerType(this._previous().toString(), null, null);\n        // sampled_texture_type less_than type_decl greater_than\n        // multisampled_texture_type less_than type_decl greater_than\n        if (this._match(TokenTypes.sampled_texture_type) ||\n            this._match(TokenTypes.multisampled_texture_type)) {\n            const sampler = this._previous();\n            this._consume(TokenTypes.tokens.less_than, \"Expected '<' for sampler type.\");\n            const format = this._type_decl();\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for sampler type.\");\n            return new SamplerType(sampler.toString(), format, null);\n        }\n        // storage_texture_type less_than texel_format comma access_mode greater_than\n        if (this._match(TokenTypes.storage_texture_type)) {\n            const sampler = this._previous();\n            this._consume(TokenTypes.tokens.less_than, \"Expected '<' for sampler type.\");\n            const format = this._consume(TokenTypes.texel_format, \"Invalid texel format.\").toString();\n            this._consume(TokenTypes.tokens.comma, \"Expected ',' after texel format.\");\n            const access = this._consume(TokenTypes.access_mode, \"Expected access mode for storage texture type.\").toString();\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for sampler type.\");\n            return new SamplerType(sampler.toString(), format, access);\n        }\n        return null;\n    }\n    _attribute() {\n        // attr ident paren_left (literal_or_ident comma)* literal_or_ident paren_right\n        // attr ident\n        let attributes = [];\n        while (this._match(TokenTypes.tokens.attr)) {\n            const name = this._consume(TokenTypes.attribute_name, \"Expected attribute name\");\n            const attr = new Attribute(name.toString(), null);\n            if (this._match(TokenTypes.tokens.paren_left)) {\n                // literal_or_ident\n                attr.value = this._consume(TokenTypes.literal_or_ident, \"Expected attribute value\").toString();\n                if (this._check(TokenTypes.tokens.comma)) {\n                    this._advance();\n                    do {\n                        const v = this._consume(TokenTypes.literal_or_ident, \"Expected attribute value\").toString();\n                        if (!(attr.value instanceof Array)) {\n                            attr.value = [attr.value];\n                        }\n                        attr.value.push(v);\n                    } while (this._match(TokenTypes.tokens.comma));\n                }\n                this._consume(TokenTypes.tokens.paren_right, \"Expected ')'\");\n            }\n            attributes.push(attr);\n        }\n        // Deprecated:\n        // attr_left (attribute comma)* attribute attr_right\n        while (this._match(TokenTypes.tokens.attr_left)) {\n            if (!this._check(TokenTypes.tokens.attr_right)) {\n                do {\n                    const name = this._consume(TokenTypes.attribute_name, \"Expected attribute name\");\n                    const attr = new Attribute(name.toString(), null);\n                    if (this._match(TokenTypes.tokens.paren_left)) {\n                        // literal_or_ident\n                        attr.value = [\n                            this._consume(TokenTypes.literal_or_ident, \"Expected attribute value\").toString(),\n                        ];\n                        if (this._check(TokenTypes.tokens.comma)) {\n                            this._advance();\n                            do {\n                                const v = this._consume(TokenTypes.literal_or_ident, \"Expected attribute value\").toString();\n                                attr.value.push(v);\n                            } while (this._match(TokenTypes.tokens.comma));\n                        }\n                        this._consume(TokenTypes.tokens.paren_right, \"Expected ')'\");\n                    }\n                    attributes.push(attr);\n                } while (this._match(TokenTypes.tokens.comma));\n            }\n            // Consume ]]\n            this._consume(TokenTypes.tokens.attr_right, \"Expected ']]' after attribute declarations\");\n        }\n        if (attributes.length == 0)\n            return null;\n        return attributes;\n    }\n}\n\n/**\n * @author Brendan Duncan / https://github.com/brendan-duncan\n */\nclass VariableInfo {\n    constructor(node, group, binding) {\n        this.group = group;\n        this.binding = binding;\n        this.node = node;\n    }\n    get name() {\n        return this.node.name;\n    }\n    get type() {\n        return this.node.type;\n    }\n    get attributes() {\n        return this.node.attributes;\n    }\n}\nclass FunctionInfo {\n    constructor(node) {\n        this.inputs = [];\n        this.node = node;\n    }\n    get name() {\n        return this.node.name;\n    }\n    get returnType() {\n        return this.node.returnType;\n    }\n    get args() {\n        return this.node.args;\n    }\n    get attributes() {\n        return this.node.attributes;\n    }\n}\nclass InputInfo {\n    constructor(name, type, input, locationType, location) {\n        this.name = name;\n        this.type = type;\n        this.input = input;\n        this.locationType = locationType;\n        this.location = location;\n        this.interpolation = this.interpolation;\n    }\n}\nclass MemberInfo {\n}\nclass TypeInfo {\n    constructor(align, size) {\n        this.align = align;\n        this.size = size;\n    }\n}\nclass BufferInfo extends TypeInfo {\n    constructor(name, type) {\n        super(0, 0);\n        this.name = name;\n        this.type = type;\n    }\n}\nclass BindGropEntry {\n    constructor(type, resource) {\n        this.type = type;\n        this.resource = resource;\n    }\n}\nclass EntryFunctions {\n    constructor() {\n        this.vertex = [];\n        this.fragment = [];\n        this.compute = [];\n    }\n}\nclass WgslReflect {\n    constructor(code) {\n        /// All top-level structs in the shader.\n        this.structs = [];\n        /// All top-level uniform vars in the shader.\n        this.uniforms = [];\n        /// All top-level storage vars in the shader.\n        this.storage = [];\n        /// All top-level texture vars in the shader;\n        this.textures = [];\n        // All top-level sampler vars in the shader.\n        this.samplers = [];\n        /// All top-level functions in the shader.\n        this.functions = [];\n        /// All top-level type aliases in the shader.\n        this.aliases = [];\n        if (code)\n            this.initialize(code);\n    }\n    initialize(code) {\n        const parser = new WgslParser();\n        this.ast = parser.parse(code);\n        this.entry = new EntryFunctions();\n        for (const node of this.ast) {\n            if (node.astNodeType == \"struct\")\n                this.structs.push(node);\n            if (node.astNodeType == \"alias\")\n                this.aliases.push(node);\n            if (this.isUniformVar(node)) {\n                const v = node;\n                const g = this.getAttributeNum(node, \"group\", 0);\n                const b = this.getAttributeNum(node, \"binding\", 0);\n                this.uniforms.push(new VariableInfo(v, g, b));\n            }\n            if (this.isStorageVar(node)) {\n                const v = node;\n                const g = this.getAttributeNum(node, \"group\", 0);\n                const b = this.getAttributeNum(node, \"binding\", 0);\n                this.storage.push(new VariableInfo(v, g, b));\n            }\n            if (this.isTextureVar(node)) {\n                const v = node;\n                const g = this.getAttributeNum(node, \"group\", 0);\n                const b = this.getAttributeNum(node, \"binding\", 0);\n                this.textures.push(new VariableInfo(v, g, b));\n            }\n            if (this.isSamplerVar(node)) {\n                const v = node;\n                const g = this.getAttributeNum(node, \"group\", 0);\n                const b = this.getAttributeNum(node, \"binding\", 0);\n                this.samplers.push(new VariableInfo(v, g, b));\n            }\n            if (node instanceof Function) {\n                const fn = new FunctionInfo(node);\n                fn.inputs = this._getInputs(node.args);\n                this.functions.push(fn);\n                const vertexStage = this.getAttribute(node, \"vertex\");\n                const fragmentStage = this.getAttribute(node, \"fragment\");\n                const computeStage = this.getAttribute(node, \"compute\");\n                const stage = vertexStage || fragmentStage || computeStage;\n                if (stage) {\n                    this.entry[stage.name].push(fn);\n                }\n            }\n        }\n    }\n    isTextureVar(node) {\n        return (node instanceof Var &&\n            node.type !== null &&\n            WgslReflect.textureTypes.indexOf(node.type.name) != -1);\n    }\n    isSamplerVar(node) {\n        return (node instanceof Var &&\n            node.type !== null &&\n            WgslReflect.samplerTypes.indexOf(node.type.name) != -1);\n    }\n    isUniformVar(node) {\n        return node instanceof Var && node.storage == \"uniform\";\n    }\n    isStorageVar(node) {\n        return node instanceof Var && node.storage == \"storage\";\n    }\n    getAttributeNum(node, name, defaultValue) {\n        const a = this.getAttribute(node, name);\n        if (a == null) {\n            return defaultValue;\n        }\n        let v = a !== null && a.value !== null ? a.value : defaultValue;\n        if (v instanceof Array) {\n            v = v[0];\n        }\n        if (typeof v === \"number\") {\n            return v;\n        }\n        if (typeof v === \"string\") {\n            return parseInt(v);\n        }\n        return defaultValue;\n    }\n    getAttribute(node, name) {\n        const obj = node;\n        if (!obj || !obj[\"attributes\"])\n            return null;\n        const attrs = obj[\"attributes\"];\n        for (let a of attrs) {\n            if (a.name == name)\n                return a;\n        }\n        return null;\n    }\n    _getInputs(args, inputs = undefined) {\n        if (inputs === undefined)\n            inputs = [];\n        for (const arg of args) {\n            const input = this._getInputInfo(arg);\n            if (input !== null)\n                inputs.push(input);\n            const struct = this.getStruct(arg.type);\n            if (struct)\n                this._getInputs(struct.members, inputs);\n        }\n        return inputs;\n    }\n    _getInputInfo(node) {\n        const location = this.getAttribute(node, \"location\") || this.getAttribute(node, \"builtin\");\n        if (location !== null) {\n            const interpolation = this.getAttribute(node, \"interpolation\");\n            const info = new InputInfo(node.name, node.type, node, location.name, this._parseInt(location.value));\n            if (interpolation !== null) {\n                info.interpolation = this._parseString(interpolation.value);\n            }\n            return info;\n        }\n        return null;\n    }\n    _parseString(s) {\n        if (s instanceof Array) {\n            s = s[0];\n        }\n        return s;\n    }\n    _parseInt(s) {\n        if (s instanceof Array) {\n            s = s[0];\n        }\n        const n = parseInt(s);\n        return isNaN(n) ? s : n;\n    }\n    getStruct(name) {\n        if (name === null)\n            return null;\n        if (name instanceof Struct)\n            return name;\n        if (name instanceof Type) {\n            name = name.name;\n        }\n        for (const u of this.structs) {\n            if (u.name == name)\n                return u;\n        }\n        return null;\n    }\n    getAlias(type) {\n        if (type === null)\n            return null;\n        if (type instanceof Node) {\n            if (!(type instanceof Type)) {\n                return null;\n            }\n            type = type.name;\n        }\n        for (const u of this.aliases) {\n            if (u.name == type)\n                return u.type;\n        }\n        return null;\n    }\n    getBindGroups() {\n        const groups = [];\n        function _makeRoom(group, binding) {\n            if (group >= groups.length)\n                groups.length = group + 1;\n            if (groups[group] === undefined)\n                groups[group] = [];\n            if (binding >= groups[group].length)\n                groups[group].length = binding + 1;\n        }\n        for (const u of this.uniforms) {\n            _makeRoom(u.group, u.binding);\n            const group = groups[u.group];\n            group[u.binding] = new BindGropEntry(\"buffer\", this.getUniformBufferInfo(u));\n        }\n        for (const u of this.storage) {\n            _makeRoom(u.group, u.binding);\n            const group = groups[u.group];\n            group[u.binding] = new BindGropEntry(\"storage\", this.getStorageBufferInfo(u));\n        }\n        for (const t of this.textures) {\n            _makeRoom(t.group, t.binding);\n            const group = groups[t.group];\n            group[t.binding] = new BindGropEntry(\"texture\", t);\n        }\n        for (const t of this.samplers) {\n            _makeRoom(t.group, t.binding);\n            const group = groups[t.group];\n            group[t.binding] = new BindGropEntry(\"sampler\", t);\n        }\n        return groups;\n    }\n    getStorageBufferInfo(node) {\n        if (node instanceof VariableInfo) {\n            node = node.node;\n        }\n        if (!this.isStorageVar(node))\n            return null;\n        const group = this.getAttributeNum(node, \"group\", 0);\n        const binding = this.getAttributeNum(node, \"binding\", 0);\n        const info = this._getUniformInfo(node);\n        info.group = group;\n        info.binding = binding;\n        return info;\n    }\n    /// Returns information about a struct type, null if the type is not a struct.\n    getStructInfo(node) {\n        var _a, _b, _c, _d, _e;\n        if (node === null)\n            return null;\n        const struct = node instanceof Struct ? node : this.getStruct(node.type);\n        if (!struct)\n            return null;\n        let offset = 0;\n        let lastSize = 0;\n        let lastOffset = 0;\n        let structAlign = 0;\n        let buffer = new BufferInfo(node.name, node instanceof Var ? node.type : null);\n        buffer.members = [];\n        for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {\n            const member = struct.members[mi];\n            const name = member.name;\n            const info = this.getTypeInfo(member);\n            if (!info)\n                continue;\n            const type = member.type;\n            const align = info.align;\n            const size = info.size;\n            offset = this._roundUp(align, offset + lastSize);\n            lastSize = size;\n            lastOffset = offset;\n            structAlign = Math.max(structAlign, align);\n            const isArray = member.type.astNodeType === \"array\";\n            const s = this.getStruct(type) ||\n                (isArray ? this.getStruct((_a = type[\"format\"]) === null || _a === void 0 ? void 0 : _a.name) : null);\n            const isStruct = !!s;\n            const si = isStruct ? this.getStructInfo(s) : undefined;\n            const arrayStride = ((_b = si === null || si === void 0 ? void 0 : si.size) !== null && _b !== void 0 ? _b : isArray)\n                ? (_c = this.getTypeInfo(type[\"format\"])) === null || _c === void 0 ? void 0 : _c.size\n                : (_d = this.getTypeInfo(member.type)) === null || _d === void 0 ? void 0 : _d.size;\n            const arrayCount = (_e = member.type[\"count\"]) !== null && _e !== void 0 ? _e : 0;\n            const members = isStruct ? si === null || si === void 0 ? void 0 : si.members : undefined;\n            const u = new MemberInfo();\n            u.node = member;\n            u.name = name;\n            u.offset = offset;\n            u.size = size;\n            u.type = type;\n            u.isArray = isArray;\n            u.arrayCount = arrayCount;\n            u.arrayStride = arrayStride;\n            u.isStruct = isStruct;\n            u.members = members;\n            buffer.members.push(u);\n        }\n        buffer.size = this._roundUp(structAlign, lastOffset + lastSize);\n        buffer.align = structAlign;\n        buffer.isArray = false;\n        buffer.isStruct = true;\n        buffer.arrayCount = 0;\n        return buffer;\n    }\n    _getUniformInfo(node) {\n        var _a, _b, _c, _d, _e;\n        const structInfo = this.getStructInfo(node);\n        if (structInfo !== null)\n            return structInfo;\n        var n = node;\n        const typeInfo = this.getTypeInfo(n.type);\n        if (typeInfo === null)\n            return null;\n        const info = new BufferInfo(node.name, n.type);\n        info.align = typeInfo.align;\n        info.size = typeInfo.size;\n        let s = this.getStruct((_a = n.type[\"format\"]) === null || _a === void 0 ? void 0 : _a.name);\n        let si = s ? this.getStructInfo(s) : undefined;\n        info.isArray = n.type.astNodeType === \"array\";\n        info.isStruct = !!s;\n        info.members = info.isStruct ? si === null || si === void 0 ? void 0 : si.members : undefined;\n        info.name = n.name;\n        info.type = n.type;\n        info.arrayStride =\n            ((_b = si === null || si === void 0 ? void 0 : si.size) !== null && _b !== void 0 ? _b : info.isArray)\n                ? (_c = this.getTypeInfo(n.type[\"format\"])) === null || _c === void 0 ? void 0 : _c.size\n                : (_d = this.getTypeInfo(n.type)) === null || _d === void 0 ? void 0 : _d.size;\n        info.arrayCount = parseInt((_e = n.type[\"count\"]) !== null && _e !== void 0 ? _e : 0);\n        return info;\n    }\n    getUniformBufferInfo(uniform) {\n        if (!this.isUniformVar(uniform.node))\n            return null;\n        const info = this._getUniformInfo(uniform.node);\n        info.group = uniform.group;\n        info.binding = uniform.binding;\n        return info;\n    }\n    getTypeInfo(type) {\n        var _a;\n        if (type === null || type === undefined)\n            return null;\n        const explicitSize = this.getAttributeNum(type, \"size\", 0);\n        const explicitAlign = this.getAttributeNum(type, \"align\", 0);\n        if (type instanceof Member)\n            type = type.type;\n        if (type instanceof Type) {\n            const alias = this.getAlias(type.name);\n            if (alias !== null) {\n                type = alias;\n            }\n            else {\n                const struct = this.getStruct(type.name);\n                if (struct !== null)\n                    type = struct;\n            }\n        }\n        {\n            const info = WgslReflect.typeInfo[type.name];\n            if (info !== undefined) {\n                const divisor = type[\"format\"] === \"f16\" ? 2 : 1;\n                return new TypeInfo(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));\n            }\n        }\n        {\n            const info = WgslReflect.typeInfo[type.name.substring(0, type.name.length - 1)];\n            if (info) {\n                const divisor = type.name[type.name.length - 1] === \"h\" ? 2 : 1;\n                return new TypeInfo(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));\n            }\n        }\n        if (type.name == \"array\") {\n            let align = 8;\n            let size = 8;\n            // Type                 AlignOf(T)          Sizeof(T)\n            // array<E, N>          AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))\n            // array<E>             AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))  (N determined at runtime)\n            //\n            // @stride(Q)\n            // array<E, N>          AlignOf(E)          N * Q\n            //\n            // @stride(Q)\n            // array<E>             AlignOf(E)          Nruntime * Q\n            //const E = type.format.name;\n            const E = this.getTypeInfo(type[\"format\"]);\n            if (E !== null) {\n                size = E.size;\n                align = E.align;\n            }\n            const N = parseInt((_a = type[\"count\"]) !== null && _a !== void 0 ? _a : 1);\n            const stride = this.getAttributeNum(type, \"stride\", this._roundUp(align, size));\n            size = N * stride;\n            if (explicitSize)\n                size = explicitSize;\n            return new TypeInfo(Math.max(explicitAlign, align), Math.max(explicitSize, size));\n        }\n        if (type instanceof Struct) {\n            let align = 0;\n            let size = 0;\n            // struct S     AlignOf:    max(AlignOfMember(S, M1), ... , AlignOfMember(S, MN))\n            //              SizeOf:     roundUp(AlignOf(S), OffsetOfMember(S, L) + SizeOfMember(S, L))\n            //                          Where L is the last member of the structure\n            let offset = 0;\n            let lastSize = 0;\n            let lastOffset = 0;\n            for (const m of type.members) {\n                const mi = this.getTypeInfo(m);\n                align = Math.max(mi.align, align);\n                offset = this._roundUp(mi.align, offset + lastSize);\n                lastSize = mi.size;\n                lastOffset = offset;\n            }\n            size = this._roundUp(align, lastOffset + lastSize);\n            return new TypeInfo(Math.max(explicitAlign, align), Math.max(explicitSize, size));\n        }\n        return null;\n    }\n    _roundUp(k, n) {\n        return Math.ceil(n / k) * k;\n    }\n}\n// Type                 AlignOf(T)          Sizeof(T)\n// i32, u32, or f32     4                   4\n// atomic<T>            4                   4\n// vec2<T>              8                   8\n// vec3<T>              16                  12\n// vec4<T>              16                  16\n// mat2x2<f32>          8                   16\n// mat3x2<f32>          8                   24\n// mat4x2<f32>          8                   32\n// mat2x3<f32>          16                  32\n// mat3x3<f32>          16                  48\n// mat4x3<f32>          16                  64\n// mat2x4<f32>          16                  32\n// mat3x4<f32>          16                  48\n// mat4x4<f32>          16                  64\nWgslReflect.typeInfo = {\n    f16: { align: 2, size: 2 },\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    atomic: { align: 4, size: 4 },\n    vec2: { align: 8, size: 8 },\n    vec3: { align: 16, size: 12 },\n    vec4: { align: 16, size: 16 },\n    mat2x2: { align: 8, size: 16 },\n    mat3x2: { align: 8, size: 24 },\n    mat4x2: { align: 8, size: 32 },\n    mat2x3: { align: 16, size: 32 },\n    mat3x3: { align: 16, size: 48 },\n    mat4x3: { align: 16, size: 64 },\n    mat2x4: { align: 16, size: 32 },\n    mat3x4: { align: 16, size: 48 },\n    mat4x4: { align: 16, size: 64 },\n};\nWgslReflect.textureTypes = TokenTypes.any_texture_type.map((t) => {\n    return t.name;\n});\nWgslReflect.samplerTypes = TokenTypes.sampler_type.map((t) => {\n    return t.name;\n});\n\nconst roundUpToMultipleOf = (v, multiple) => (((v + multiple - 1) / multiple) | 0) * multiple;\n// TODO: fix better?\nconst isTypedArray = (arr) => arr && typeof arr.length === 'number' && arr.buffer instanceof ArrayBuffer && typeof arr.byteLength === 'number';\nclass TypedArrayViewGenerator {\n    arrayBuffer;\n    byteOffset;\n    constructor(sizeInBytes) {\n        this.arrayBuffer = new ArrayBuffer(sizeInBytes);\n        this.byteOffset = 0;\n    }\n    align(alignment) {\n        this.byteOffset = roundUpToMultipleOf(this.byteOffset, alignment);\n    }\n    pad(numBytes) {\n        this.byteOffset += numBytes;\n    }\n    getView(Ctor, numElements) {\n        const view = new Ctor(this.arrayBuffer, this.byteOffset, numElements);\n        this.byteOffset += view.byteLength;\n        return view;\n    }\n}\nconst b = {\n    i32: { numElements: 1, align: 4, size: 4, type: 'i32', View: Int32Array },\n    u32: { numElements: 1, align: 4, size: 4, type: 'u32', View: Uint32Array },\n    f32: { numElements: 1, align: 4, size: 4, type: 'f32', View: Float32Array },\n    f16: { numElements: 1, align: 2, size: 2, type: 'u16', View: Uint16Array },\n    vec2f: { numElements: 2, align: 8, size: 8, type: 'f32', View: Float32Array },\n    vec2i: { numElements: 2, align: 8, size: 8, type: 'i32', View: Int32Array },\n    vec2u: { numElements: 2, align: 8, size: 8, type: 'u32', View: Uint32Array },\n    vec2h: { numElements: 2, align: 4, size: 4, type: 'u16', View: Uint16Array },\n    vec3i: { numElements: 3, align: 16, size: 12, type: 'i32', View: Int32Array },\n    vec3u: { numElements: 3, align: 16, size: 12, type: 'u32', View: Uint32Array },\n    vec3f: { numElements: 3, align: 16, size: 12, type: 'f32', View: Float32Array },\n    vec3h: { numElements: 3, align: 8, size: 6, type: 'u16', View: Uint16Array },\n    vec4i: { numElements: 4, align: 16, size: 16, type: 'i32', View: Int32Array },\n    vec4u: { numElements: 4, align: 16, size: 16, type: 'u32', View: Uint32Array },\n    vec4f: { numElements: 4, align: 16, size: 16, type: 'f32', View: Float32Array },\n    vec4h: { numElements: 4, align: 8, size: 8, type: 'u16', View: Uint16Array },\n    // AlignOf(vecR)\tSizeOf(array<vecR, C>)\n    mat2x2f: { numElements: 4, align: 8, size: 16, type: 'f32', View: Float32Array },\n    mat2x2h: { numElements: 4, align: 4, size: 8, type: 'u16', View: Uint16Array },\n    mat3x2f: { numElements: 6, align: 8, size: 24, type: 'f32', View: Float32Array },\n    mat3x2h: { numElements: 6, align: 4, size: 12, type: 'u16', View: Uint16Array },\n    mat4x2f: { numElements: 8, align: 8, size: 32, type: 'f32', View: Float32Array },\n    mat4x2h: { numElements: 8, align: 4, size: 16, type: 'u16', View: Uint16Array },\n    mat2x3f: { numElements: 8, align: 16, size: 32, pad: [3, 1], type: 'f32', View: Float32Array },\n    mat2x3h: { numElements: 8, align: 8, size: 16, pad: [3, 1], type: 'u16', View: Uint16Array },\n    mat3x3f: { numElements: 12, align: 16, size: 48, pad: [3, 1], type: 'f32', View: Float32Array },\n    mat3x3h: { numElements: 12, align: 8, size: 24, pad: [3, 1], type: 'u16', View: Uint16Array },\n    mat4x3f: { numElements: 16, align: 16, size: 64, pad: [3, 1], type: 'f32', View: Float32Array },\n    mat4x3h: { numElements: 16, align: 8, size: 32, pad: [3, 1], type: 'u16', View: Uint16Array },\n    mat2x4f: { numElements: 8, align: 16, size: 32, type: 'f32', View: Float32Array },\n    mat2x4h: { numElements: 8, align: 8, size: 16, type: 'u16', View: Uint16Array },\n    mat3x4f: { numElements: 12, align: 16, size: 48, pad: [3, 1], type: 'f32', View: Float32Array },\n    mat3x4h: { numElements: 12, align: 8, size: 24, pad: [3, 1], type: 'u16', View: Uint16Array },\n    mat4x4f: { numElements: 16, align: 16, size: 64, type: 'f32', View: Float32Array },\n    mat4x4h: { numElements: 16, align: 8, size: 32, type: 'u16', View: Uint16Array },\n};\nconst typeInfo = {\n    ...b,\n    'vec2<i32>': b.vec2f,\n    'vec2<u32>': b.vec2i,\n    'vec2<f32>': b.vec2u,\n    'vec2<f16>': b.vec2h,\n    'vec3<i32>': b.vec3i,\n    'vec3<u32>': b.vec3u,\n    'vec3<f32>': b.vec3f,\n    'vec3<f16>': b.vec3h,\n    'vec4<i32>': b.vec4i,\n    'vec4<u32>': b.vec4u,\n    'vec4<f32>': b.vec4f,\n    'vec4<f16>': b.vec4h,\n    'mat2x2<f32>': b.mat2x2f,\n    'mat2x2<f16>': b.mat2x2h,\n    'mat3x2<f32>': b.mat3x2f,\n    'mat3x2<f16>': b.mat3x2h,\n    'mat4x2<f32>': b.mat4x2f,\n    'mat4x2<f16>': b.mat4x2h,\n    'mat2x3<f32>': b.mat2x3f,\n    'mat2x3<f16>': b.mat2x3h,\n    'mat3x3<f32>': b.mat3x3f,\n    'mat3x3<f16>': b.mat3x3h,\n    'mat4x3<f32>': b.mat4x3f,\n    'mat4x3<f16>': b.mat4x3h,\n    'mat2x4<f32>': b.mat2x4f,\n    'mat2x4<f16>': b.mat2x4h,\n    'mat3x4<f32>': b.mat3x4f,\n    'mat3x4<f16>': b.mat3x4h,\n    'mat4x4<f32>': b.mat4x4f,\n    'mat4x4<f16>': b.mat4x4h,\n};\n// This needs to be fixed! \nfunction getSizeOfStructDef(fieldDef) {\n    if (Array.isArray(fieldDef)) {\n        return fieldDef.length * getSizeOfStructDef(fieldDef[0]);\n    }\n    else {\n        return fieldDef.size;\n    }\n}\n/**\n * Creates a set of named TypedArray views on an ArrayBuffer\n * @param structDef Definition of the various types of views.\n * @param arrayBuffer Optional ArrayBuffer to use (if one provided one will be created)\n * @param offset Optional offset in existing ArrayBuffer to start the views.\n * @returns A bunch of named TypedArray views and the ArrayBuffer\n */\nfunction makeTypedArrayViews(structDef, arrayBuffer, offset) {\n    const baseOffset = offset || 0;\n    const buffer = arrayBuffer || new ArrayBuffer(getSizeOfStructDef(structDef));\n    const makeViews = (structDef) => {\n        if (Array.isArray(structDef)) {\n            return structDef.map(elemDef => makeViews(elemDef));\n        }\n        else if (typeof structDef === 'string') {\n            throw Error('unreachable');\n        }\n        else {\n            const fields = structDef.fields;\n            if (fields) {\n                const views = {};\n                for (const [name, def] of Object.entries(fields)) {\n                    views[name] = makeViews(def);\n                }\n                return views;\n            }\n            else {\n                const { size, offset, type } = structDef;\n                try {\n                    const { View } = typeInfo[type];\n                    const numElements = size / View.BYTES_PER_ELEMENT;\n                    return new View(buffer, baseOffset + offset, numElements);\n                }\n                catch {\n                    throw new Error(`unknown type: ${type}`);\n                }\n            }\n        }\n    };\n    return { views: makeViews(structDef), arrayBuffer: buffer };\n}\n/**\n * Given a set of TypeArrayViews and matching JavaScript data\n * sets the content of the views.\n * @param data The new values\n * @param views TypedArray views as returned from {@link makeTypedArrayViews}\n */\nfunction setStructuredView(data, views) {\n    if (data === undefined) {\n        return;\n    }\n    else if (isTypedArray(views)) {\n        const view = views;\n        if (view.length === 1 && typeof data === 'number') {\n            view[0] = data;\n        }\n        else {\n            view.set(data);\n        }\n    }\n    else if (Array.isArray(views)) {\n        const asArray = views;\n        data.forEach((newValue, ndx) => {\n            setStructuredView(newValue, asArray[ndx]);\n        });\n    }\n    else {\n        const asViews = views;\n        for (const [key, newValue] of Object.entries(data)) {\n            const view = asViews[key];\n            if (view) {\n                setStructuredView(newValue, view);\n            }\n        }\n    }\n}\n/**\n * Given a StructDefinition, create matching TypedArray views\n * @param structDef A StructDefinition as returned from {@link makeShaderDataDefinitions}\n * @param arrayBuffer Optional ArrayBuffer for the views\n * @param offset Optional offset into the ArrayBuffer for the views\n * @returns TypedArray views for the various named fields of the structure as well\n *    as a `set` function to make them easy to set, and the arrayBuffer\n */\nfunction makeStructuredView(structDef, arrayBuffer, offset = 0) {\n    const views = makeTypedArrayViews(structDef, arrayBuffer, offset);\n    return {\n        ...views,\n        set(data) {\n            setStructuredView(data, views.views);\n        },\n    };\n}\nfunction addMember(reflect, m, offset) {\n    if (m.isArray) {\n        if (m.isStruct) {\n            return [\n                m.name,\n                new Array(m.arrayCount).fill(0).map((_, ndx) => {\n                    return addMembers(reflect, m.members, m.size / m.arrayCount, offset + (m.offset || 0) + m.size / m.arrayCount * ndx);\n                }),\n            ];\n        }\n        else {\n            return [\n                m.name,\n                {\n                    offset: offset + (m.offset || 0),\n                    size: m.size,\n                    type: m.type.format.format\n                        ? `${m.type.format.name}<${m.type.format.format.name}>`\n                        : m.type.format.name,\n                    numElements: m.arrayCount,\n                },\n            ];\n        }\n    }\n    else if (m.isStruct) {\n        return [\n            m.name,\n            addMembers(reflect, m.members, m.size, offset + (m.offset || 0)),\n        ];\n    }\n    else {\n        return [\n            m.name,\n            {\n                offset: offset + (m.offset || 0),\n                size: m.size,\n                type: m.type?.format\n                    ? `${m.type.name}<${m.type.format.name}>`\n                    : m.type?.name || m.name,\n            },\n        ];\n    }\n}\nfunction addMembers(reflect, members, size, offset = 0) {\n    const fields = Object.fromEntries(members.map(m => {\n        return addMember(reflect, m, offset);\n    }));\n    return {\n        fields,\n        size,\n    };\n}\n/**\n * Given a WGSL shader, returns data definitions for structures,\n * uniforms, and storage buffers\n *\n * Example:\n *\n * ```js\n * const code = `\n * struct MyStruct {\n *    color: vec4<f32>,\n *    brightness: f32,\n *    kernel: array<f32, 9>,\n * };\n * @group(0) @binding(0) var<uniform> myUniforms: MyUniforms;\n * `;\n * const defs = makeShaderDataDefinitions(code);\n * const myUniformValues = makeStructuredView(defs.uniforms.myUniforms);\n *\n * myUniformValues.set({\n *   color: [1, 0, 1, 1],\n *   brightness: 0.8,\n *   kernel: [\n *      1, 0, -1,\n *      2, 0, -2,\n *      1, 0, -1,\n *   ],\n * });\n * device.queue.writeBuffer(uniformBuffer, 0, myUniformValues.arrayBuffer);\n * ```\n *\n * @param code WGSL shader. Note: it is not required for this to be a complete shader\n * @returns definitions of the structures by name. Useful for passing to {@link makeStructuredView}\n */\nfunction makeShaderDataDefinitions(code) {\n    const reflect = new WgslReflect(code);\n    const structs = Object.fromEntries(reflect.structs.map(struct => {\n        const info = reflect.getStructInfo(struct);\n        return [struct.name, addMembers(reflect, info.members, info.size)];\n    }));\n    const uniforms = Object.fromEntries(reflect.uniforms.map(uniform => {\n        const info = reflect.getUniformBufferInfo(uniform);\n        const member = addMember(reflect, info, 0)[1];\n        member.binding = info.binding;\n        member.group = info.group;\n        return [uniform.name, member];\n    }));\n    const storages = Object.fromEntries(reflect.storage.map(uniform => {\n        const info = reflect.getStorageBufferInfo(uniform);\n        const member = addMember(reflect, info, 0)[1];\n        member.binding = info.binding;\n        member.group = info.group;\n        return [uniform.name, member];\n    }));\n    return {\n        structs,\n        storages,\n        uniforms,\n    };\n}\nconst s_views = new WeakMap();\nfunction getViewsByCtor(arrayBuffer) {\n    let viewsByCtor = s_views.get(arrayBuffer);\n    if (!viewsByCtor) {\n        viewsByCtor = new Map();\n        s_views.set(arrayBuffer, viewsByCtor);\n    }\n    return viewsByCtor;\n}\nfunction getView(arrayBuffer, Ctor) {\n    const viewsByCtor = getViewsByCtor(arrayBuffer);\n    let view = viewsByCtor.get(Ctor);\n    if (!view) {\n        view = new Ctor(arrayBuffer);\n        viewsByCtor.set(Ctor, view);\n    }\n    return view;\n}\nfunction setStructuredValues(fieldDef, data, arrayBuffer, offset = 0) {\n    const asIntrinsicDefinition = fieldDef;\n    if (asIntrinsicDefinition.type) {\n        const type = typeInfo[asIntrinsicDefinition.type];\n        const view = getView(arrayBuffer, type.View);\n        const index = (offset + asIntrinsicDefinition.offset) / view.BYTES_PER_ELEMENT;\n        if (typeof data === 'number') {\n            view[index] = data;\n        }\n        else {\n            view.set(data, index);\n        }\n    }\n    else if (Array.isArray(fieldDef)) {\n        // It's IntrinsicDefinition[] or StructDefinition[]\n        data.forEach((newValue, ndx) => {\n            setStructuredValues(fieldDef[ndx], newValue, arrayBuffer, offset);\n        });\n    }\n    else {\n        // It's StructDefinition\n        const asStructDefinition = fieldDef;\n        for (const [key, newValue] of Object.entries(data)) {\n            const fieldDef = asStructDefinition.fields[key];\n            if (fieldDef) {\n                setStructuredValues(fieldDef, newValue, arrayBuffer, offset);\n            }\n        }\n    }\n}\n\nexport { TypedArrayViewGenerator, isTypedArray, makeShaderDataDefinitions, makeStructuredView, makeTypedArrayViews, roundUpToMultipleOf, setStructuredValues, setStructuredView };\n//# sourceMappingURL=webgpu-utils.module.js.map\n",null,null,null,null],"names":["__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","value","get","Node","constructor","isAstNode","astNodeType","Statement","super","Function","name","args","returnType","body","this","StaticAssert","expression","While","condition","For","init","increment","Var","type","storage","access","Let","Const","IncrementOperator","AssignOperator","_a","TokenClass","parse","val","key","Error","Increment","operator","variable","Assign","Call","Loop","continuing","Switch","If","elseif","_else","else","Return","Struct","members","Enable","Alias","Discard","Break","Continue","Type","TemplateType","format","PointerType","ArrayType","attributes","count","SamplerType","Expression","StringExpr","toString","CreateExpr","CallExpr","VariableExpr","LiteralExpr","BitcastExpr","TypecastExpr","GroupingExpr","contents","Operator","UnaryOperator","right","BinaryOperator","left","SwitchCase","Case","selector","Default","Argument","ElseIf","Member","Attribute","TokenType","rule","TokenTypes","none","reserved","eof","token","asm","bf16","do","enum","f16","f64","handle","i8","i16","i64","mat","premerge","regardless","typedef","u8","u16","u64","unless","using","vec","void","keywords","array","keyword","atomic","bool","f32","i32","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","ptr","sampler","sampler_comparison","struct","texture_1d","texture_2d","texture_2d_array","texture_3d","texture_cube","texture_cube_array","texture_multisampled_2d","texture_storage_1d","texture_storage_2d","texture_storage_2d_array","texture_storage_3d","texture_depth_2d","texture_depth_2d_array","texture_depth_cube","texture_depth_cube_array","texture_depth_multisampled_2d","u32","vec2","vec3","vec4","bitcast","block","break","case","continue","default","discard","enable","fallthrough","false","fn","for","function","if","let","const","loop","while","private","read","read_write","return","switch","true","uniform","var","workgroup","write","r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm_srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm_srgb","rgb10a2unorm","rg11b10float","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","static_assert","tokens","decimal_float_literal","hex_float_literal","int_literal","uint_literal","ident","and","and_and","arrow","attr","attr_left","attr_right","forward_slash","bang","bracket_left","bracket_right","brace_left","brace_right","colon","comma","equal","equal_equal","not_equal","greater_than","greater_than_equal","shift_right","less_than","less_than_equal","shift_left","modulo","minus","minus_minus","period","plus","plus_plus","or","or_or","paren_left","paren_right","semicolon","star","tilde","underscore","xor","plus_equal","minus_equal","times_equal","division_equal","modulo_equal","and_equal","or_equal","xor_equal","shift_right_equal","shift_left_equal","storage_class","access_mode","sampler_type","sampled_texture_type","multisampled_texture_type","storage_texture_type","depth_texture_type","any_texture_type","texel_format","const_literal","literal_or_ident","element_count_expression","template_types","attribute_name","assignment_operators","increment_operators","Token","lexeme","line","WgslScanner","source","_tokens","_start","_current","_line","_source","scanTokens","_isAtEnd","scanToken","push","_advance","_isWhitespace","_peekAhead","commentLevel","matchType","matchedType","_findType","foundLessThan","ti","length","indexOf","_addToken","lookAheadLexeme","lookAhead","maxLookAhead","li","_match","match","exec","index","c","amount","offset","text","substring","WgslParser","tokensOrCode","_initialize","statements","statement","_global_decl_or_directive","scanner","_error","message","console","error","_peek","types","_check","i","l","_consume","tk","Array","t","_previous","_type_alias","_enable_directive","attrs","_attribute","_var","_global_variable_decl","_let","_global_constant_decl","_struct","_struct_decl","_fn","_function_decl","argAttrs","typeAttrs","_type_decl","_return","_compound_statement","_statement","_if_statement","_switch_statement","_loop_statement","_for_statement","_while_statement","_static_assert_statement","result","_return_statement","_variable_statement","_increment_decrement_statement","_func_call_statement","_assignment_statement","_optional_paren_expression","_for_init","_short_circuit_or_expression","_for_increment","_variable_decl","savedPos","_unary_expression","decrement","isUnderscore","_argument_expression_list","s","_switch_body","cases","_case_selectors","_case_body","_cases","selectors","nextStatement","_elseif_statement","expr","_short_circuit_and_expr","_inclusive_or_expression","_exclusive_or_expression","_and_expression","_equality_expression","_relational_expression","_shift_expression","_additive_expression","_multiplicative_expression","_singular_expression","_primary_expression","p","_postfix_expression","postfix","_paren_expression","arg","memberAttrs","memberName","memberType","_const_expression","alias","pointer","decl","_texture_sampler_types","countInt","parseInt","v","VariableInfo","node","group","binding","FunctionInfo","inputs","InputInfo","input","locationType","location","interpolation","MemberInfo","TypeInfo","align","size","BufferInfo","BindGropEntry","resource","EntryFunctions","vertex","fragment","compute","WgslReflect","code","structs","uniforms","textures","samplers","functions","aliases","initialize","parser","ast","entry","isUniformVar","g","getAttributeNum","b","isStorageVar","isTextureVar","isSamplerVar","_getInputs","vertexStage","getAttribute","fragmentStage","computeStage","stage","textureTypes","samplerTypes","defaultValue","a","obj","undefined","_getInputInfo","getStruct","info","_parseInt","_parseString","n","isNaN","u","getAlias","getBindGroups","groups","_makeRoom","getUniformBufferInfo","getStorageBufferInfo","_getUniformInfo","getStructInfo","_b","_c","_d","_e","lastSize","lastOffset","structAlign","buffer","mi","ml","member","getTypeInfo","_roundUp","Math","max","isArray","isStruct","si","arrayStride","arrayCount","structInfo","typeInfo","explicitSize","explicitAlign","divisor","E","m","k","ceil","addMember","reflect","fill","map","_","ndx","addMembers","numElements","fields","Object","fromEntries","assert","msg","TypedArrayBufferViewInstances","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","kTypedArrayBufferViews","subarrayAsU8","buf","start","ArrayBuffer","byteLength","byteOffset","BYTES_PER_ELEMENT","nextPowerOfTwo","clz32","makeBufferWithContents","device","data","usage","createBuffer","mappedAtCreation","alignment","Number","isInteger","src","dst","getMappedRange","set","unmap","numericScalarLt","numericVectorLt","values","SortInPlaceElementType","comp","entryPoint","vec2u","vec3u","vec4u","vec2i","vec3i","vec4i","vec2f","vec3f","vec4f","computeSizeOfElement","elemType","defs","storages","makeShaderDataDefinitions","definition","createSortKeyValueInPlaceShader","mode","wgs","kv_pairs","createDistanceMapShader","dist","distType","initKeyValueInPlaceSort","alignedN","elemSize","maxWorkGroupSizeForMemory","limits","maxComputeWorkgroupStorageSize","workGroupSize","min","maxComputeWorkgroupSizeX","workGroupCount","shader","createShaderModule","computePipeline","createComputePipeline","layout","module","bindGroupKV","createBindGroup","getBindGroupLayout","entries","paramBuffers","bindGroupPs","helper","h","algorithm","params","GPUBufferUsage","UNIFORM","bindGroupP","local_disperse","big_flip","big_disperse","local_bms","hh","config","_Sorter_internals","encode","encoder","pass","beginComputePass","setPipeline","setBindGroup","forEach","bg","dispatchWorkgroups","end","sort","createCommandEncoder","queue","submit","finish","destroy","_Sorter_distInternals","keys","bindGroup","initDistanceMap","_Sorter_sortInternals"],"mappings":"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","x_google_ignoreList":[0]}